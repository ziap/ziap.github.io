<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Zap&#x27;s website</title>
      <link>https://ziap.github.io</link>
      <description>Bui Huy Giap&#x27;s personal website and blog</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://ziap.github.io/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Fri, 13 Dec 2024 00:00:00 +0000</lastBuildDate>
      <item>
          <title>My desktop customization journey</title>
          <pubDate>Fri, 13 Dec 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/customization/</link>
          <guid>https://ziap.github.io/blog/customization/</guid>
          <description xml:base="https://ziap.github.io/blog/customization/">&lt;p&gt;I’m a massive tinkerer, I love breaking things to see why it broke and how to
fix them. I prefer breaking software because if it goes too far, I can just
reinstall everything. It was a great learning experience, and I’m glad that I
had the time and opportunity to do it. As I grow up, messing with software is
no longer just for fun and learning, it’s had become a way for me to optimize
my workflow, to be more in tune with technology.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>String matching with compile time hash tables</title>
          <pubDate>Fri, 29 Nov 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/string-matching/</link>
          <guid>https://ziap.github.io/blog/string-matching/</guid>
          <description xml:base="https://ziap.github.io/blog/string-matching/">&lt;p&gt;I use switch statements a lot in C and even C++. The syntax sucks, but the
alternatives are either too verbose (table of function pointers) or don’t
express the intention well (if-else chain). It was sad, but I accepted long ago
that switch statements only work on numeric types and usually use the
alternatives on strings and arrays. But switching on a string has become a
common operation for me, and I recently ended up with a reasonably good
solution for it.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Approximating sin(2πx)</title>
          <pubDate>Tue, 05 Nov 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/sin-approx/</link>
          <guid>https://ziap.github.io/blog/sin-approx/</guid>
          <description xml:base="https://ziap.github.io/blog/sin-approx/">&lt;p&gt;I use trigonometric functions extremely often, ever since I started doing
programming. They show up everywhere, especially in graphics, and while they’re
not the most efficient operation, they are widely available in programming
languages. This is not the case if you’re programming in embedded systems or
&lt;a href=&quot;&#x2F;blog&#x2F;wasm&quot;&gt;WebAssembly&lt;&#x2F;a&gt;, so I tried to compute them myself.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Introduction to freestanding WebAssembly</title>
          <pubDate>Mon, 21 Oct 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/wasm/</link>
          <guid>https://ziap.github.io/blog/wasm/</guid>
          <description xml:base="https://ziap.github.io/blog/wasm/">&lt;p&gt;I’ve been using WebAssembly (WASM) for quite a while, and the learning
resources are sparse and incomplete. This is especially true for freestanding
WASM, or using WASM directly without using tools that make interacting with the
web easier. This is an attempt for me to reflect on what I discovered and
hopefully introduce more people to this weird intersection of system
programming and web development.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>I switched to Fish as my interactive shell</title>
          <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/fish-shell/</link>
          <guid>https://ziap.github.io/blog/fish-shell/</guid>
          <description xml:base="https://ziap.github.io/blog/fish-shell/">&lt;p&gt;ZSH has been my shell of choice since I started my command-line-centric
workflow. It’s a popular shell with a &lt;a href=&quot;&#x2F;&#x2F;github.com&#x2F;zsh-users&quot;&gt;large&lt;&#x2F;a&gt;
&lt;a href=&quot;&#x2F;&#x2F;ohmyz.sh&#x2F;&quot;&gt;community&lt;&#x2F;a&gt; and an unprecedented level of customizability. ZSH is
also POSIX-compliant, which was very important to me for some reason. However,
after some reconsideration, I decided to port my config to the Fish shell, and
this is why.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>My personal strategies for arena allocation</title>
          <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/arena/</link>
          <guid>https://ziap.github.io/blog/arena/</guid>
          <description xml:base="https://ziap.github.io/blog/arena/">&lt;p&gt;A drawback that people often mention when programming in C is the lack of RAII.
This is sometimes good as it causes me to avoid small, random allocations and
incentivize grouping data into large, contiguous memory regions to make them
faster and more manageable. However, small, random allocations are sometimes
unavoidable, and there should still be a way to manage them. Instead of
grouping data into arrays, we can instead group data by their &lt;em&gt;lifetime&lt;&#x2F;em&gt;, and
this is where the “arena” allocator comes in.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>A game I made as a course project</title>
          <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/programming-techniques-project/</link>
          <guid>https://ziap.github.io/blog/programming-techniques-project/</guid>
          <description xml:base="https://ziap.github.io/blog/programming-techniques-project/">&lt;p&gt;I recently programmed a large chunk of the game from scratch for a university
course project. This is one of a few projects that I delivered with enough
quality and presentability. So I wanted to document my process of making it,
what I learned, and how I applied my knowledge from and outside the course.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Easy, efficient, and practical queue implementation</title>
          <pubDate>Sat, 24 Feb 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/queue/</link>
          <guid>https://ziap.github.io/blog/queue/</guid>
          <description xml:base="https://ziap.github.io/blog/queue/">&lt;p&gt;From breadth-first search to task scheduling, queues are extremely useful in
computer programming. Although &lt;a href=&quot;&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Double-ended_queue#Operations&quot;&gt;many programming
languages&lt;&#x2F;a&gt; support them,
I think that it’s important to understand and know how to implement them. I
like to implement data structures on-the-fly and customize them for the problem
I’m trying to solve. A more practical reason to understand queues is that
JavaScript doesn’t have an efficient queue implementation.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>A faster, more flexible alternative to run-time polymorphism in C++ feat. Rust</title>
          <pubDate>Sun, 11 Feb 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/polymorphism/</link>
          <guid>https://ziap.github.io/blog/polymorphism/</guid>
          <description xml:base="https://ziap.github.io/blog/polymorphism/">&lt;p&gt;When I first heard about run-time polymorphism in C++ using virtual methods, my
first thoughts were like, “This is cool and all, but why would I ever use
this?” Then I continued to ignore it because I could always just work around it
instead of using it. Until recently, my college lecturer told me that using
virtual methods is great for designing and maintaining applications with
thousands of objects. I figured that I should write about what run-time
polymorphism is, and why I still think that I don’t need it.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Rewriting my website and starting a blog</title>
          <pubDate>Fri, 09 Feb 2024 00:00:00 +0000</pubDate>
          <author>Zap</author>
          <link>https://ziap.github.io/blog/new-website/</link>
          <guid>https://ziap.github.io/blog/new-website/</guid>
          <description xml:base="https://ziap.github.io/blog/new-website/">&lt;p&gt;I already have a website hosted on GitHub pages. It was built around 2 years
ago as a way to quickly browse and access my web projects. Basically, it was
just a grid of project thumbnails, which is pretty boring. During the last 2
years, I changed bits and pieces of it, but it’s still the same boring layout
with only a list of projects and some basic information.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
