<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          Implementing a 64-bit Pseudo-random number generator | Zap's website
        
      
    </title><link href=/styles/fonts.css rel=stylesheet><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Zap</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">Implementing a 64-bit Pseudo-random number generator</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Sat, Mar 22 2025</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="3327 words"> 14 minutes read </abbr></div></div></header><article class=content__body><p>Let’s face it, determinism is boring. I’ve been using Pseudo-random number generators (PRNGs) for as long as I can remember. My usual PRNG is PCG-32 with a fixed increment, but it’s time for me to pick a larger PRNG for 64-bit output and multithreaded generation.</p><span id=continue-reading></span><p>I mostly use PRNGs for Monte Carlo simulations and randomized algorithms. For these applications, existing PRNGs in many programming languages usually have these problems:<ul><li><p>Performance: The biggest culprit is the MT19937 generator. Although implemented as the default PRNG in C++, Python, and countless other languages, this PRNG is needlessly big and slow. I wanted a PRNG that is small enough so that it can be incorporated nicely into the algorithm using it. It should also produce numbers fast enough so that it doesn’t become the bottleneck of the algorithm.</p><li><p>Statistical quality: Some default PRNG, such as <code>rand()</code> in C, or even the aforementioned MT19937, failed to pass statistical tests. Passing doesn’t mean that the PRNG is good, but failing means that it generates biased output, and may tamper with the behavior of the algorithm using it.</p><li><p>Reproducibility: I want to be able to control and reproduce the output of algorithms using PRNG. This means controlling both the PRNG implementation and the seeding procedure. Some existing PRNG doesn’t have a specified algorithm (<code>RAND_MAX</code> is implementation defined) and/or doesn’t allow you to seed it (<code>Math.random()</code> in JavaScript), so it’s not a good idea to rely on them.</p></ul><p>There’s also the concern of cryptographic security, but most of my usage are non-adversarial, so it’s not important to me. Another issue that recently caught my attention is correlation in parallel environment, which I will address in this article.<h1 id=problems-with-my-current-prng>Problems with my current PRNG</h1><p>As mentioned above, my previous PRNG of choice is PCG-32, specifically this function:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const </span><span>Pcg32 </span><span style=color:#c678dd>= struct </span><span>{
</span><span>  </span><span style=color:#e06c75>state</span><span>: </span><span style=color:#c678dd>u64</span><span>,
</span><span>
</span><span>  </span><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>self</span><span>: </span><span style=color:#c678dd>*Pcg32</span><span>) </span><span style=color:#c678dd>u32 </span><span>{
</span><span>    </span><span style=color:#c678dd>const</span><span> state </span><span style=color:#c678dd>=</span><span> self.state;
</span><span>    self.state </span><span style=color:#c678dd>=</span><span> state </span><span style=color:#c678dd>*% </span><span style=color:#e5c07b>0x5851f42d4c957f2d </span><span style=color:#c678dd>+% </span><span style=color:#e5c07b>0x14057b7ef767814f</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>xorshifted</span><span>: </span><span style=color:#c678dd>u32 = </span><span style=color:#61afef>@truncate</span><span>((state </span><span style=color:#c678dd>^ </span><span>(state </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>18</span><span>)) </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>27</span><span>);
</span><span>    </span><span style=color:#c678dd>const </span><span style=color:#e06c75>rot</span><span>: </span><span style=color:#c678dd>u5 = </span><span style=color:#61afef>@intCast</span><span>(state </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>59</span><span>);
</span><span>    </span><span style=color:#c678dd>return </span><span>(xorshifted </span><span style=color:#c678dd>>></span><span> rot) </span><span style=color:#c678dd>| </span><span>(xorshifted </span><span style=color:#c678dd><< -%</span><span> rot);
</span><span>  }
</span><span>};
</span></code></pre><p>It’s fast, have robust statistical quality, and extremely easy to seed. But unfortunately, it only produces 32-bit output. As the 32-bit variant requires 64-bit arithmetic, the 64-bit variant of PCG requires 128-bit arithmetic, which is quite slow on modern hardware. I can modify PCG-32 to generate two words at a time with vectorization:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>fn </span><span style=color:#61afef>next_u64</span><span>(</span><span style=color:#e06c75>self</span><span>: </span><span style=color:#c678dd>*Pcg32</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>  </span><span style=color:#c678dd>const</span><span> s0 </span><span style=color:#c678dd>=</span><span> self.state;
</span><span>  </span><span style=color:#c678dd>const</span><span> s1 </span><span style=color:#c678dd>=</span><span> s0 </span><span style=color:#c678dd>*% </span><span style=color:#e5c07b>0x5851f42d4c957f2d </span><span style=color:#c678dd>+% </span><span style=color:#e5c07b>0x14057b7ef767814f</span><span>;
</span><span>  self.state </span><span style=color:#c678dd>=</span><span> s0 </span><span style=color:#c678dd>*% </span><span style=color:#e5c07b>0x685f98a2018fade9 </span><span style=color:#c678dd>+% </span><span style=color:#e5c07b>0x1a08ee1184ba6d32</span><span>;
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>s</span><span>: </span><span style=color:#61afef>@Vector</span><span>(</span><span style=color:#e5c07b>2</span><span>, u64) </span><span style=color:#c678dd>=</span><span> .{ s0, s1 };
</span><span>
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>mask</span><span>: </span><span style=color:#61afef>@Vector</span><span>(</span><span style=color:#e5c07b>2</span><span>, u64) </span><span style=color:#c678dd>= comptime </span><span style=color:#61afef>@splat</span><span>(</span><span style=color:#e5c07b>0xffffffff</span><span>);
</span><span>  </span><span style=color:#c678dd>const</span><span> xorshifted </span><span style=color:#c678dd>= </span><span>((s </span><span style=color:#c678dd>^ </span><span>(s </span><span style=color:#c678dd>>> </span><span style=color:#61afef>@splat</span><span>(</span><span style=color:#e5c07b>18</span><span>))) </span><span style=color:#c678dd>>> </span><span style=color:#61afef>@splat</span><span>(</span><span style=color:#e5c07b>27</span><span>)) & mask;
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>rot</span><span>: </span><span style=color:#61afef>@Vector</span><span>(</span><span style=color:#e5c07b>2</span><span>, u5) </span><span style=color:#c678dd>= </span><span style=color:#61afef>@intCast</span><span>(s </span><span style=color:#c678dd>>> </span><span style=color:#61afef>@splat</span><span>(</span><span style=color:#e5c07b>59</span><span>));
</span><span>  </span><span style=color:#c678dd>const</span><span> out </span><span style=color:#c678dd>= </span><span>(xorshifted </span><span style=color:#c678dd>>></span><span> rot) </span><span style=color:#c678dd>| </span><span>(xorshifted </span><span style=color:#c678dd><< -%</span><span> rot);
</span><span>
</span><span>  </span><span style=color:#c678dd>return </span><span>(out[</span><span style=color:#e5c07b>0</span><span>] </span><span style=color:#c678dd><< </span><span style=color:#e5c07b>32</span><span>) </span><span style=color:#c678dd>| </span><span style=color:#61afef>@as</span><span>(u32, </span><span style=color:#61afef>@truncate</span><span>(out[</span><span style=color:#e5c07b>1</span><span>]));
</span><span>}
</span></code></pre><p>This makes PCG-32 faster than PCG-64 on my machine, but it requires specialized instruction, and the period of the generator is now 2^63, which is too small for the size of the output. The small period causes the generator to omit some 64-bit values, which causes problems detectable with <a href=//www.pcg-random.org/posts/birthday-test.html>the birthday test</a>.<p>So, to improve upon PCG-32, we need a generator that:<ul><li>Can generate both 32-bit and 64-bit values faster than PCG-32<li>Have a large period (at least 2^128)</ul><h1 id=selecting-a-new-prng>Selecting a new PRNG</h1><p>With the requirements listed above, the obvious choice is to use the <a href=//prng.di.unimi.it/>Xoshiro family</a> of PRNG, specifically the Xoshiro256++ variant. It is fast, has great statistical quality, and has a period of 2^256. However, there are a few problems with the generator.<p>Firstly, it’s not trivial to seed, seeding Xoshiro256 requires 256 bits of high hamming weight. Without sufficient entropy, you need to use a <a href=//www.pcg-random.org/posts/developing-a-seed_seq-alternative.html>seed sequence</a>, or, as the authors of Xoshiro recommended, a secondary PRNG.<blockquote><p>We suggest to use SplitMix64 to initialize the state of our generators starting from a 64-bit seed, as research has shown that initialization must be performed with a generator radically different in nature from the one initialized to avoid correlation on similar seeds.</blockquote><p>Secondly, this is mostly the matter of taste, but I prefer generators based on congruential arithmetic, or LCGs. They are usually simpler to understand and implement, and their statistical quality have been rigorously evaluated. And on modern hardware, they are very efficient… up to a certain size.<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const </span><span>Lehmer64 </span><span style=color:#c678dd>= struct </span><span>{
</span><span>  </span><span style=color:#e06c75>state</span><span>: </span><span style=color:#c678dd>u128</span><span>,
</span><span>
</span><span>  </span><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>self</span><span>: </span><span style=color:#c678dd>*Lehmer64</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>    </span><span style=color:#5c6370>// Multiplier from: https://arxiv.org/abs/2001.05304
</span><span>    self.state </span><span style=color:#c678dd>*%= </span><span style=color:#e5c07b>0xdefba91144f2b375</span><span>;
</span><span>    </span><span style=color:#c678dd>return </span><span style=color:#61afef>@intCast</span><span>(self.state </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>64</span><span>);
</span><span>  }
</span><span>};
</span></code></pre><p>At 128-bit of state, you need to use a half-width multiplier to avoid the full 128-bit by 128-bit multiplication overhead. This negatively affect statistical quality, but it’s remedied by the 128-bit state space and truncation. This generator is considered <a href=//lemire.me/blog/2019/03/19/the-fastest-conventional-random-number-generator-that-can-pass-big-crush/>one of the fastest</a>, and serves as a good baseline. I was wondering if I can further reduce the statistical quality to increase the speed and state size, but Sebastiano Vigna — one of the author of the Xoshiro family — already have a suggestion:<blockquote><p>Nonetheless, you might wish to use at all costs, for some reason, a PRNG based on congruential arithmetic with 64 bits of output, 128 bits or more of state, and using 128-bit multiplications.<p>In that case, you have a much better option: Marsaglia’s Multiply-With-Carry generators and their generalizations. For example, MWC128 is a generator with 128 bits of state that is much faster than a PCG generator, and the design can be extended, say, to 256 bits of state.</blockquote><p>The quote above comes from <a href=//pcg.di.unimi.it/pcg.php>an article debunking the PCG scheme</a>. While the concerns that the author raise don’t significantly impact my common usage of the generator, he made some very good points worth thinking, especially the ones above about MWC generators.<h1 id=multiply-with-carry-prngs>Multiply-With-Carry PRNGs</h1><p>George Marsaglia’s Multiply-With-Carry generators are exactly what I need. They use a carefully designed multiplier with reduced statistical quality to improve the execution speed and period length. Vigna provides a 256-bit instance of the generator, and shown that it’s one of the fastest 64-bit generator available:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const </span><span>Mwc256 </span><span style=color:#c678dd>= struct </span><span>{
</span><span>  </span><span style=color:#e06c75>state</span><span>: [</span><span style=color:#e5c07b>3</span><span>]</span><span style=color:#c678dd>u64</span><span>,
</span><span>  </span><span style=color:#e06c75>carry</span><span>: </span><span style=color:#c678dd>u64</span><span>,
</span><span>
</span><span>  </span><span style=color:#c678dd>const</span><span> MUL </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0xfff62cf2ccc0cdaf</span><span>;
</span><span>
</span><span>  </span><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>self</span><span>: </span><span style=color:#c678dd>*Mwc256</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>    </span><span style=color:#c678dd>const</span><span> result </span><span style=color:#c678dd>=</span><span> self.state[</span><span style=color:#e5c07b>2</span><span>];
</span><span>    </span><span style=color:#c678dd>const</span><span> m </span><span style=color:#c678dd>= </span><span style=color:#61afef>@as</span><span>(u128, self.state[</span><span style=color:#e5c07b>0</span><span>]) </span><span style=color:#c678dd>*</span><span> MUL </span><span style=color:#c678dd>+</span><span> self.carry;
</span><span>    self.state[</span><span style=color:#e5c07b>0</span><span>] </span><span style=color:#c678dd>=</span><span> self.state[</span><span style=color:#e5c07b>1</span><span>];
</span><span>    self.state[</span><span style=color:#e5c07b>1</span><span>] </span><span style=color:#c678dd>=</span><span> self.state[</span><span style=color:#e5c07b>2</span><span>];
</span><span>    self.state[</span><span style=color:#e5c07b>2</span><span>] </span><span style=color:#c678dd>= </span><span style=color:#61afef>@truncate</span><span>(m);
</span><span>    self.carry </span><span style=color:#c678dd>= </span><span style=color:#61afef>@intCast</span><span>(m </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>64</span><span>);
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>  }
</span><span>};
</span></code></pre><p>The Lehmer64 generator above requires a 128-bit by 64-bit multiplication. When compiled to x64, it consists of 2 multiplications and 1 addition. In contrast, the MWC-256 generator requires a 64-bit by 64-bit multiplication and a 128-bit addition, which compiles down to 1 multiplication and 2 additions instead, which is slightly faster. There’s also the overhead of shuffling the state array, but it can be done very efficiently when the generator is inlined.<h2 id=properties>Properties</h2><p>But what are the properties of MWC generators, and how good are they compared to other schemes? Each MWC generator is just an LCG underneath, for the instance above, it’s equivalent to the following LCG:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const</span><span> A </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>6277015918605909751934968372698009048156780102314631364608</span><span>;
</span><span style=color:#c678dd>const</span><span> M </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>115790506197124082927983825842145069363743217527239024849216517993585891606527</span><span>;
</span><span>
</span><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>state</span><span>: </span><span style=color:#c678dd>*u256</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result</span><span>: </span><span style=color:#c678dd>u64 = </span><span style=color:#61afef>@truncate</span><span>(state</span><span style=color:#c678dd>.* >> </span><span style=color:#e5c07b>128</span><span>);
</span><span>  state</span><span style=color:#c678dd>.* = </span><span style=color:#61afef>@intCast</span><span>((</span><span style=color:#61afef>@as</span><span>(u512, state</span><span style=color:#c678dd>.*</span><span>) </span><span style=color:#c678dd>*</span><span> A) </span><span style=color:#c678dd>%</span><span> M);
</span><span>  </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>It’s amazing how the multiplier <code>A</code> can be carefully designed so that the 256-bit multiplication and modulo can be reduced into a 64-bit multiplication, a 128-bit addition, and storage-bit truncation. This particular form of the multiplier, along with its statistical implications, will be explored later. But first, here are some properties of the MWC-256 generator:<p>The modulus <code>M</code> is actually <code>MOD * 2^192 - 1</code>, and is a prime number. LCGs with power-of-2 modulus, such as Lehmer64 and PCG generators, have the problem of low bits have a shorter period than the high bits, which isn’t a problem with prime modulus LCGs. The generator has 2 cycles, each with a period of <code>M / 2</code>, which is also a prime number. Since the generator is fundamentally just an LCG, it inherits all features and properties of LCGs.<h1 id=statistical-testing>Statistical testing</h1><p>Although we have 256-bit of state to work with, LCG has some serious statistical flaws. Because I don’t have the resource for full-scale statistical testing, I’m going to perform what called small-scale testing. The idea originates from the <a href=//www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf>PCG paper</a>, which argues that passing statistical tests is not enough, you need to test scaled down versions of your generator and make sure that they also pass. Luckily, it’s very easy to scale down MWC-256, and LCG based generators in general. Here’s a variant with 40-bit of state and 8-bit of output, in LCG format.<pre class=language-c data-lang=c style=color:#dcdfe4;background-color:#282c34><code class=language-c data-lang=c><span>uint8_t </span><span style=color:#61afef>mwc_next</span><span>(uint64_t </span><span style=color:#c678dd>*</span><span style=color:#e06c75>state</span><span>) {
</span><span>    </span><span style=color:#c678dd>const</span><span> __uint128_t mul </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>902823936</span><span>;
</span><span>    uint8_t s </span><span style=color:#c678dd>= *</span><span>state </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>20</span><span>;
</span><span>    </span><span style=color:#c678dd>*</span><span>state </span><span style=color:#c678dd>= </span><span>(mul </span><span style=color:#c678dd>* *</span><span>state) </span><span style=color:#c678dd>% </span><span style=color:#e5c07b>924491710463</span><span>;
</span><span>    </span><span style=color:#c678dd>return</span><span> s;
</span><span>}
</span></code></pre><p>If we plug this generator to <a href=//pracrand.sourceforge.net/>PractRand</a>, we can observe that it fails after 32 MB of output. In comparison, here’s a 40-bit variant of PCG XSH-RR:<pre class=language-c data-lang=c style=color:#dcdfe4;background-color:#282c34><code class=language-c data-lang=c><span>uint16_t </span><span style=color:#61afef>pcg_next</span><span>(uint64_t </span><span style=color:#c678dd>*</span><span style=color:#e06c75>state</span><span>) {
</span><span>    uint64_t s </span><span style=color:#c678dd>= *</span><span>state;
</span><span>    </span><span style=color:#c678dd>*</span><span>state </span><span style=color:#c678dd>= </span><span>(s </span><span style=color:#c678dd>* </span><span style=color:#e5c07b>568512975829 </span><span style=color:#c678dd>+ </span><span style=color:#e5c07b>1</span><span>) </span><span style=color:#c678dd>& </span><span style=color:#e5c07b>0xffffffffff</span><span>;
</span><span>
</span><span>    uint16_t xorshifted </span><span style=color:#c678dd>= </span><span>(s </span><span style=color:#c678dd>^ </span><span>(s </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>10</span><span>)) </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>20</span><span>;
</span><span>    uint16_t rot </span><span style=color:#c678dd>=</span><span> s </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>36</span><span>;
</span><span>    </span><span style=color:#c678dd>return </span><span>(xorshifted </span><span style=color:#c678dd><<</span><span> rot) </span><span style=color:#c678dd>| </span><span>(xorshifted </span><span style=color:#c678dd>>> </span><span>(</span><span style=color:#e5c07b>16 </span><span style=color:#c678dd>-</span><span> rot));
</span><span>}
</span></code></pre><p>This generator fails after 16 GB of output, which is a lot better than the MWC generator. I’d also like to test a 40-bit xoshiro generator, but I don’t understand the math enough to do so. However, we can safely say that at the same state size, the MWC generators are inferior. This is why I decided to improve the statistical quality of MWC with a PCG-style output permutation function.<h1 id=adding-an-output-permutation>Adding an output permutation</h1><p>Currently, this is the code for the LCG form of the MWC-256 generator:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>state</span><span>: </span><span style=color:#c678dd>*u256</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result</span><span>: </span><span style=color:#c678dd>u64 = </span><span style=color:#61afef>@truncate</span><span>(state</span><span style=color:#c678dd>.* >> </span><span style=color:#e5c07b>128</span><span>);
</span><span>  state</span><span style=color:#c678dd>.* = </span><span style=color:#61afef>@intCast</span><span>((</span><span style=color:#61afef>@as</span><span>(u512, state</span><span style=color:#c678dd>.*</span><span>) </span><span style=color:#c678dd>*</span><span> A) </span><span style=color:#c678dd>%</span><span> M);
</span><span>  </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>In case you haven’t known this already, this is not just a regular LCG, but rather a truncated LCG. These often have better statistical quality, as they can discard bits with low period and improve security while doing so (although truncated LCGs are vulnerable to LLL based attacks). Dropping the 128 lower bits seems reasonable because they are only shifted during the state transition, only the higher bits have something interesting going on. This is why the algorithm can be implemented using 64-bit multiplication.<p>The 64 highest bits are also discarded, and unlike the lower bits, they are actually quite thoroughly mixed during the state transition. Therefor, it’s a good idea to only discard the 128 lower bits and fully use the 128 upper bits. But the output is 64-bit, so the most obvious output permutation is to xor them together, similar to the PCG XSL output permutation.<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>fn </span><span style=color:#61afef>next</span><span>(</span><span style=color:#e06c75>state</span><span>: </span><span style=color:#c678dd>*u256</span><span>) </span><span style=color:#c678dd>u64 </span><span>{
</span><span>  </span><span style=color:#c678dd>const </span><span style=color:#e06c75>result</span><span>: </span><span style=color:#c678dd>u64 = </span><span style=color:#61afef>@truncate</span><span>((state</span><span style=color:#c678dd>.* >> </span><span style=color:#e5c07b>128</span><span>) </span><span style=color:#c678dd>^ </span><span>(state</span><span style=color:#c678dd>.* >> </span><span style=color:#e5c07b>192</span><span>));
</span><span>  state</span><span style=color:#c678dd>.* = </span><span style=color:#61afef>@intCast</span><span>((</span><span style=color:#61afef>@as</span><span>(u512, state</span><span style=color:#c678dd>.*</span><span>) </span><span style=color:#c678dd>*</span><span> A) </span><span style=color:#c678dd>%</span><span> M);
</span><span>  </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>With this tiny modification, the failure point of the MWC generator moved from 16 MB to 64 GB of output! This is roughly the same as, if not better than PCG, probably thanks to the prime modulus. If we scale the generators to their full state size, we can assume that if statistical flaws were found for PCG-64, it would take 2^128 times that effort to find statistical flaws for our new generator.<p>It might be tempting to add a random rotate, similar to the XSL-RR variant of PCG, but I think that the statistical quality is already good enough. Also, random rotate is used to make sure that all bits of the LCG have full period, which we already solved by using a prime modulus. This gives us a new generator with the speed of MWC and the enhanced statistical quality of PCG. If we combine the state transition and output permutation, then we get an operation as follow:<pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>const</span><span> m </span><span style=color:#c678dd>= </span><span style=color:#61afef>@as</span><span>(u128, self.state[</span><span style=color:#e5c07b>0</span><span>]) </span><span style=color:#c678dd>*</span><span> MUL </span><span style=color:#c678dd>+</span><span> self.carry;
</span><span style=color:#c678dd>return </span><span style=color:#61afef>@truncate</span><span>(m) </span><span style=color:#c678dd>^ </span><span style=color:#61afef>@intCast</span><span>(m </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>64</span><span>);
</span></code></pre><p>This is very similar to a recently popular operation for non-cryptographic hashing: folded-multiply. It’s widely used in many hash functions, such as <a href=//xxhash.com/>xxhash</a>, <a href=//github.com/wangyi-fudan/wyhash>wyhash</a> and its <a href=//github.com/golang/go/blob/d12fe60004ae5e4024c8a93f4f7de7183bb61576/src/runtime/hash64.go#L25>many</a> <a href=//github.com/rust-lang/rustc-hash>derivatives</a>. Although there are no formal analysis of this operation that I know of, considering its widespread use it must be really effective.<p>So, this generator needs a name. We can use the PCG naming scheme and call it PCG MWC XSL 256/64. Or we can use the Xo(ro)shiro naming convention and call it mwc256x. But I’m free to come up with any name I want, so I’m going to call it FMC-256 or Folded-multiply-carry 256. This is because the generator feels like an MWC and folded-multiply tightly coupled together.<h1 id=searching-for-a-multiplier>Searching for a multiplier</h1><p>Let’s finally address the elephant in the room: the particular form of the multiplier that makes this generator so efficient on modern hardware. In fact, both the modulus and the multiplier are carefully derived for efficient execution. The LCG modulus <code>M</code> actually has this form:<pre style=color:#dcdfe4;background-color:#282c34><code><span>M = (MUL << 192) - 1
</span></code></pre><p>Where <code>MUL</code> is the MWC multiplier. The LCG multiplier <code>A</code> is actually the <a href=//en.wikipedia.org/wiki/Modular_multiplicative_inverse>multiplicative modular inverse</a> of <code>2^64</code> and <code>M</code>, which means that the MWC have the same lattice structure as a LCG with multiplier <code>2^64</code> and prime modulus <code>M</code>. There are two major issues with this construction:<ul><li><p>The multiplier is not a primitive root modulo <code>M</code>, so the generator can’t be full-period. The maximum period is only <code>M / 2</code>, which is also chosen to be prime.</p><li><p><code>2^64</code> have terrible lattice structure. It’s both too small compared to <code>M</code> and too simple. Because of that, we can’t use the usual method to find good multipliers.</p></ul><p>But how do you usually find a good LCG multiplier? A reliable method is to evaluate them with the <a href=//en.wikipedia.org/wiki/Spectral_test>spectral test</a>. So let’s do that with Vigna’s multiplier:<table><thead><tr><th>f2<th>f3<th>f4<th>f5<th>f6<tbody><tr><td>0.000000<td>0.000000<td>0.840802<td>0.000002<td>0.000564</table><p>This looks utterly terrible, so is every other multipliers. I don’t know what other criteria did Vigna use to search for a multiplier other than the period length, but I have a heuristic in mind. LCG multipliers are used not just for, well, LCGs, but they are also used as output permutation and hash functions. There’s no way for me to quantify this, but empirically, good LCG multiplier tend to work really well as a bit-mixer. So let’s test Vigna’s multiplier as a 64-bit LCG multiplier:<table><thead><tr><th>f2<th>f3<th>f4<th>f5<th>f6<tbody><tr><td>0.905671<td>0.616314<td>0.641113<td>0.559620<td>0.601442</table><p>With this heuristic in mind, I set up a search algorithm to look for numbers <code>MUL</code> with these criteria:<ul><li>Be very large (<code>MUL > 0.75 * 2^64</code>)<li>The LCG modulus is prime (<code>(MUL << 192) - 1</code> is prime)<li>The period is prime (<code>(MUL << 191) - 1</code> is prime)<li>Have good lattice structure when used as a 64-bit LCG multiplier</ul><p>After searching for about 21 CPU hours, I came across this multiplier: <code>0xffff1aa1c69c8d92</code>. Interestingly, it’s both larger than Vigna’s multiplier and have better 64-bit LCG spectral score.<table><thead><tr><th>f2<th>f3<th>f4<th>f5<th>f6<tbody><tr><td>0.909715<td>0.721577<td>0.683022<td>0.665940<td>0.807217</table><p>Vigna might have other priorities for selecting a multiplier, so his constant might be better in ways that I’m not aware of. But I think that with the state size of 2^256 and an output permutation, a good multiplier probably won’t matter too much.<h1 id=the-final-prng>The final PRNG</h1><p>So this is the PRNG that I ended up with: FMC-256, a 256-bit multiply-with-carry pseudo-random number generator with a xor-folding output permutation. Although 256-bit is more than enough for my common usage, if I ever need more (or less) I can easily extend the design. Let’s see if it lives up to my requirements above.<h2 id=statistical-quality>Statistical quality</h2><p>With the xor-folding output function, the statistical quality of the generator is roughly on par with PCG XSH-RR of the same size. Vigna also claims that at 256-bit, the MWC alone passes all statistical tests. If I have more time and resource, I will test the full 256-bit version both with and without the output permutation to see if it’s true. But for now I can only rely on Vigna words and the small-scale testing that I’ve done.<h2 id=performance>Performance</h2><p>Measuring performance of PRNGs is a tricky task as there are so many factors at play. From my “instruction count analysis”, I predicted that MWC-256 will be a bit faster than Lehmer64, but by how much? And what about after applying the output permutation? What about 32-bit number generations? To answer these question, we decided to run a benchmark based on the task of computing PI using Monte Carlo method.<figure><img alt="Performance comparison of different prngs" src=performance.svg></figure><p>Note that for 32-bit generators, FMC-256 and Wyrand are the same generator as their 64-bit counterpart, only their output are further truncated down to 32-bit. This shows that although FMC-256 was designed for 64-bit generation, they are also quite competitive as 32-bit generators. For 64-bit generation, as predicted earlier, FMC-256 is a bit faster than Lehmer64, even with the added output permutation. It’s also the fastest generator with what I consider “enough state size (128-bit)”.<p>Through the benchmark, we can conclude that FMC-256 achieved the original performance goal: Can generate both 32-bit and 64-bit values faster than PCG-32. Although, remember that benchmark results does not fully represent real-world performance characteristics, it is only a rough estimation.<h2 id=ease-of-seeding>Ease of seeding</h2><p>One of my criticism of Xoshiro256++ is that it’s hard to seed them. Since FMC-256 is just an LCG underneath, it’s as easy to seed as an LCG. A requirement is that the state is non-zero, which corresponds to the existence of a non-zero element in the state array. Another requirement is that the state is smaller than the modulus, which corresponds to the carry being smaller than the multiplier minus 1.<p>However, there’s a problem with similar state creating correlated sequences. This is partially solved with the output permutation, but to be extra secure, the state can be advanced several times (10 from my experience) to fully mix the key. This removes the requirement of a seed sequence or separate PRNG.<h2 id=parallel-generation>Parallel generation</h2><p>Previously, when I need to run randomized algorithms on multiple thread, I usually initialize one on each thread from an external entropy source. This has several problems:<ol><li>Since I’m initializing from an external entropy source, the results are not reproducible.<li>There’s a chance that these random sequences overlap each other, creating correlation.</ol><p>The second problem can be addressed by increasing the state size, further minimizing the chance of creating overlapping sequences. But there’s a simple technique to solve both of these problems: State partitioning. Instead of choosing random seeds, we create a single generator from a single seed. To create N generators for N threads, we iteratively advance the generator by a huge jump and copy the generator. This ensures that the generators are far away from each other so that they don’t overlap, and since we’re using a single seed, the results are fully reproducible.<p>I’m not aware of a way to jump the generator ahead in MWC form, so this feature is implemented entirely in LCG form, which means doing 256-bit modular arithmetic with a prime modulus. Luckily, Zig already have 256-bit integers, so I don’t have to reimplement them. Since we’re doing multiplication, the results can overflow up to 512 bits. And 512-bit modulo is excruciatingly slow. Although jump-ahead is not a frequent operation, I can’t allow myself to write code this slow, so I optimized it to use <a href=//en.algorithmica.org/hpc/number-theory/montgomery/>Montgomery reduction</a>.<h1 id=conclusion>Conclusion</h1><p>This article documented my process of finding and implementing a 64-bit PRNG. I’m really happy with the result, as it has the state space of 256-bit, the same statistical quality as PCG (of the same size), and similar speed to Lehmer64. I’m going to use this generator for future large scale simulations (until problems start popping up). This article also mentions some other generator, so let briefly go over them and talk about the mean reason why I decided not to use them for general-purpose 64-bit generation.<p><strong>PCG 128/64:</strong> It’s not practically scalable to larger state size due to its low speed.<p><strong>Xoshiro256++:</strong> F2 Linear generators are too “magical” to me. I want to be able to understand the math before using them, and hopefully someday I will.<p><strong>Lehmer64:</strong> Similar to PCG, along with not having good statistical quality.<p><strong>SplitMix64:</strong> It generates 64-bit numbers from 64 bits of state, so it can only output a random permutation. This causes statistical issues but sometimes can be useful, like when searching for MWC multipliers.<p><strong>Wyrand:</strong> It also generates 64-bit numbers from 64 bits of state, but unlike SplitMix, it omits some numbers from its output. It’s not possible to scale the generator to 128-bit because the output function is not a bijection, so even with 128 bits of state the output’s period is less than 2^64.<p>I’m not saying by any means that the FMC-256 is perfect, but it strikes a good balance for what I want need from a PRNG. The full source code is available <a href=//github.com/ziap/fmc-prng>here</a>, but if you need a small C version, here it is:<pre class=language-c data-lang=c style=color:#dcdfe4;background-color:#282c34><code class=language-c data-lang=c><span style=color:#c678dd>typedef struct </span><span>{
</span><span>  uint64_t state[</span><span style=color:#e5c07b>3</span><span>];
</span><span>  uint64_t carry;
</span><span>} Fmc256;
</span><span>
</span><span style=color:#c678dd>#define </span><span>MUL </span><span style=color:#e5c07b>0xffff1aa1c69c8d92
</span><span>
</span><span>Fmc256 </span><span style=color:#61afef>Fmc256_new</span><span>(uint64_t </span><span style=color:#e06c75>seed</span><span>[</span><span style=color:#e5c07b>4</span><span>]) {
</span><span>  Fmc256 rng;
</span><span>  </span><span style=color:#61afef>memcpy</span><span>(</span><span style=color:#c678dd>&</span><span>rng, seed, </span><span style=color:#c678dd>sizeof</span><span>(rng));
</span><span>  rng.</span><span style=color:#e06c75>carry </span><span style=color:#c678dd>=</span><span> rng.</span><span style=color:#e06c75>carry </span><span style=color:#c678dd>% </span><span>(MUL </span><span style=color:#c678dd>- </span><span style=color:#e5c07b>2</span><span>) </span><span style=color:#c678dd>+ </span><span style=color:#e5c07b>1</span><span>;
</span><span>  </span><span style=color:#c678dd>return</span><span> rng;
</span><span>}
</span><span>
</span><span>uint64_t </span><span style=color:#61afef>Fmc256_next</span><span>(Fmc256 </span><span style=color:#c678dd>*</span><span style=color:#e06c75>rng</span><span>) {
</span><span>  uint64_t result </span><span style=color:#c678dd>=</span><span> rng->state[</span><span style=color:#e5c07b>2</span><span>] </span><span style=color:#c678dd>^</span><span> rng->carry;
</span><span>  __uint128_t m </span><span style=color:#c678dd>= </span><span>(__uint128_t)rng->state[</span><span style=color:#e5c07b>0</span><span>] </span><span style=color:#c678dd>*</span><span> MUL </span><span style=color:#c678dd>+</span><span> rng->carry;
</span><span>  rng->state[</span><span style=color:#e5c07b>0</span><span>] </span><span style=color:#c678dd>=</span><span> rng->state[</span><span style=color:#e5c07b>1</span><span>];
</span><span>  rng->state[</span><span style=color:#e5c07b>1</span><span>] </span><span style=color:#c678dd>=</span><span> rng->state[</span><span style=color:#e5c07b>2</span><span>];
</span><span>  rng->state[</span><span style=color:#e5c07b>2</span><span>] </span><span style=color:#c678dd>=</span><span> m;
</span><span>  rng->carry </span><span style=color:#c678dd>=</span><span> m </span><span style=color:#c678dd>>> </span><span style=color:#e5c07b>64</span><span>;
</span><span>  </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre></article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Zap (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>