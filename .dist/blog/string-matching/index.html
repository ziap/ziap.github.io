<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bui Huy Giap&#x27;s personal website and blog">
    <link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon">
    <title>
      
        
          String matching with compile time hash tables |
        

        Zap&#x27;s website
      
    </title>
    <link rel="stylesheet" href="/styles/base.css">
    <link rel="stylesheet" href="/styles/nav.css">
    <link rel="stylesheet" href="/styles/footer.css">
    <link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS">
    
  

  <link rel="stylesheet" href="/styles/page.css">

  </head>
  <body>
    
      <div class="nav__bg">
        <div class="nav__container">
          

<nav class="nav">
  <h3 class="nav__title">
    <a href="/" class="nav__title__link">Zap</a>
  </h3>
  <ul class="nav__links">
    
      <li><a class="nav__link" href="/works">Works</a></li>
    
      <li><a class="nav__link" href="/blog">Blog</a></li>
    
      <li><a class="nav__link" href="/about">About</a></li>
    
  </ul>
</nav>

        </div>
      </div>
    

    <div class="container">
      <main class="content">
        
  
  <header class="post-header">
    
    <h1 class="post-header__title title">String matching with compile time hash tables</h1>
    
    
      <div class="post-header__meta">
        <div class="post-header__data">
          
  <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
  <!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
  <path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/>
</svg>


          Fri, Nov 29 2024
        </div>

        <div class="post-header__data">
          
  <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
  <!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
  <path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/>
</svg>


          
  
  

  <abbr title="2378 words">
    10
    
      minutes
    
    read
  </abbr>

        </div>
      </div>
    
  </header>


  <article class="content__body">
    <p>I use switch statements a lot in C and even C++. The syntax sucks, but the
alternatives are either too verbose (table of function pointers) or don’t
express the intention well (if-else chain). It was sad, but I accepted long ago
that switch statements only work on numeric types and usually use the
alternatives on strings and arrays. But switching on a string has become a
common operation for me, and I recently ended up with a reasonably good
solution for it.</p>
<span id="continue-reading"></span><h1 id="the-problem">The problem</h1>
<p>Suppose we need to run some code based on the current weekday. We actually have
two problems: representing the weekday and performing matching on the
representation. The most straightforward way to do this is to use strings to
represent weekdays and use one of the switch statement alternatives that I
mentioned above. For example:</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::string current_weekday </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;monday&quot;</span><span>;
</span><span>
</span><span style="color:#5c6370;">// if-else chain
</span><span style="color:#c678dd;">if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;monday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_monday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;tuesday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_tuesday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;wednesday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_wednesday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;thursday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_thursday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;friday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_friday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;saturday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_saturday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else if </span><span>(current_weekday </span><span style="color:#c678dd;">== </span><span style="color:#98c379;">&quot;sunday&quot;</span><span>) {
</span><span>    </span><span style="color:#e06c75;">process_sunday</span><span>();
</span><span>} </span><span style="color:#c678dd;">else </span><span>{
</span><span>    </span><span style="color:#61afef;">fprintf</span><span>(stderr, </span><span style="color:#98c379;">&quot;Invalid weekday: `</span><span style="color:#e5c07b;">%s</span><span style="color:#98c379;">`</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&quot;</span><span>, current_weekday);
</span><span>}
</span><span>
</span><span style="color:#5c6370;">// table of function pointers
</span><span style="color:#c678dd;">using </span><span>WeekdayMap </span><span style="color:#c678dd;">=</span><span> std::unordered_map&lt;std::string_view, </span><span style="color:#c678dd;">void</span><span> process(</span><span style="color:#c678dd;">void</span><span>)&gt;;
</span><span>WeekdayMap weekday_map {
</span><span>    {</span><span style="color:#98c379;">&quot;monday&quot;</span><span>, process_monday},
</span><span>    {</span><span style="color:#98c379;">&quot;tuesday&quot;</span><span>, process_tuesday},
</span><span>    {</span><span style="color:#98c379;">&quot;wednesday&quot;</span><span>, process_wednesday},
</span><span>    {</span><span style="color:#98c379;">&quot;thursday&quot;</span><span>, process_thursday},
</span><span>    {</span><span style="color:#98c379;">&quot;friday&quot;</span><span>, process_friday},
</span><span>    {</span><span style="color:#98c379;">&quot;saturday&quot;</span><span>, process_saturday},
</span><span>    {</span><span style="color:#98c379;">&quot;sunday&quot;</span><span>, process_sunday},
</span><span>};
</span><span>
</span><span>WeekdayMap::iterator it </span><span style="color:#c678dd;">=</span><span> weekday_map.</span><span style="color:#e06c75;">find</span><span>(current_weekday);
</span><span style="color:#c678dd;">if </span><span>(it </span><span style="color:#c678dd;">!=</span><span> weekday_map.</span><span style="color:#e06c75;">end</span><span>()) {
</span><span>    it-&gt;</span><span style="color:#e06c75;">second</span><span>();
</span><span>}
</span></code></pre>
<p>There are several problems with this, but let’s address the representation
first. Strings can contain more than just the valid values. Our
<code>current_weekday</code> string can contain random gibberish or even nothing at all.
This is why the matching code needs to have a code path that handles invalid
inputs. It’s the same as the <a href="//www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar
mistake</a>,
just even worse because storing and matching on strings are more expensive than
null pointers. Before going through the solution for this, let’s take a look at
the two methods of string matching first.</p>
<p>As mentioned in the introduction, if-else chains doesn’t convey the intention
of matching on a set of values, at least in my opinion. For me, if-elses are
for checking on conditions, not values, and even if expressiveness isn’t a
problem, then performance is. The time complexity of this method is <code>O(mn)</code>
where <code>m</code> is the number of strings to match against and <code>n</code> is the average
length. Also the amount of syntax noise is insane if there isn’t enough reason
not to use it.</p>
<p>The function table approach is a bit better in terms of performance as it uses
an <code>std::unordered_map</code>, which is a stupid name for a hash table. Still,
<code>std::unordered_map</code> store its data on the heap, so this method doesn’t work
when heap allocation is expensive or unavailable. And the fact that it uses
function pointers means that you can’t capture the stack without explicitly
setting them as function arguments. We can get around this by using
<code>std::function</code> which is a polymorphic function type that supports lambdas,
which in turn supports stack capturing. But using <code>std::function</code> means that
you are using dynamic dispatch, which introduces even more performance
overhead.</p>
<h1 id="representation">Representation</h1>
<p>While the code above demonstrated a big problem with string matching in C++,
that problem actually comes from using strings in general. Strings are horrible
ways to represent a set of values, like a set of card suits ♦ ♣ ♥ ♠, a set of
people, or a set of days of the week. A better way to represent them is with
<code>enum</code>:</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">enum </span><span>Weekday {
</span><span>    WEEKDAY_MONDAY </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>,
</span><span>    WEEKDAY_TUESDAY,
</span><span>    WEEKDAY_WEDNESDAY,
</span><span>    WEEKDAY_THURSDAY,
</span><span>    WEEKDAY_FRIDAY,
</span><span>    WEEKDAY_SATURDAY,
</span><span>    WEEKDAY_SUNDAY,
</span><span>    WEEKDAY_COUNT,
</span><span>};
</span></code></pre>
<p>They are compact, and can only represent the valid values unless you explicitly
cast an integer into them. More importantly, you can use switch statements to
match on them.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>Weekday current_weekday </span><span style="color:#c678dd;">=</span><span> WEEKDAY_MONDAY;
</span><span>
</span><span style="color:#c678dd;">switch </span><span>(current_weekday) {
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_MONDAY: {
</span><span>        </span><span style="color:#e06c75;">process_monday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_TUESDAY: {
</span><span>        </span><span style="color:#e06c75;">process_tuesday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_WEDNESDAY: {
</span><span>        </span><span style="color:#e06c75;">process_wednesday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_THURSDAY: {
</span><span>        </span><span style="color:#e06c75;">process_thursday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_FRIDAY: {
</span><span>        </span><span style="color:#e06c75;">process_friday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_SATURDAY: {
</span><span>        </span><span style="color:#e06c75;">process_saturday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_SUNDAY: {
</span><span>        </span><span style="color:#e06c75;">process_sunday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_COUNT: {
</span><span>        </span><span style="color:#e06c75;">__builtin_unreachable</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>}
</span></code></pre>
<p>Using switch statements on strings is extremely convenient. The compiler will
warn you if you forgot to handle an enumerant, so adding new values is trivial.
Also notice how I add a <code>_COUNT</code> enumerant then in the switch case I have to
mark it as unreachable. The <code>_COUNT</code> enumerant is for determining the number of
elements in the enum, which is useful for iterating over all values or creating
static arrays.</p>
<h1 id="string-matching-with-enums">String matching with enums</h1>
<p>But if enums are so useful, then why do we still need string matching? The
problem is that what if the inputs are specified as strings? In the original
problem, if <code>current_weekday</code> is of type <code>std::string</code>, how do we match over
them? If we want to keep the convenience and simplicity of using enums, then
you need to convert strings into them.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>std::string current_weekday </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;monday&quot;</span><span>;
</span><span>Weekday current_weekday_enum </span><span style="color:#c678dd;">= ...</span><span>;
</span><span>
</span><span style="color:#c678dd;">switch </span><span>(current_weekday) {
</span><span>    </span><span style="color:#5c6370;">// ...
</span><span>}
</span></code></pre>
<p>And how do we convert strings into enums? with string matching! So we
transformed a string matching problem into another problem; what’s the point?
Well, this problem is very specific, unlike arbitrary code execution based on a
value, so we can construct a reusable solution.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">template</span><span>&lt;</span><span style="color:#c678dd;">typename</span><span> T, uint32_t N&gt;
</span><span>std::unordered_map&lt;std::string_view, T&gt; </span><span style="color:#61afef;">generate_map</span><span>(</span><span style="color:#c678dd;">const </span><span>std::</span><span style="color:#e06c75;">string_view </span><span>(</span><span style="color:#c678dd;">*</span><span>string_table)[N]) {
</span><span>  std::unordered_map&lt;std::string_view, T&gt; map;
</span><span>  </span><span style="color:#c678dd;">for </span><span>(uint32_t i </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>; i </span><span style="color:#c678dd;">&lt;</span><span> N; </span><span style="color:#c678dd;">++</span><span>i) {
</span><span>    map.</span><span style="color:#e06c75;">insert</span><span>({(</span><span style="color:#c678dd;">*</span><span>string_table)[i], (T)i});
</span><span>  }
</span><span>  </span><span style="color:#c678dd;">return</span><span> map;
</span><span>}
</span><span>
</span><span style="color:#c678dd;">constexpr</span><span> std::string_view Weekday_str[WEEKDAY_COUNT] </span><span style="color:#c678dd;">= </span><span>{
</span><span>  </span><span style="color:#98c379;">&quot;monday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;tuesday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;wednesday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;thursday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;friday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;saturday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;sunday&quot;
</span><span>};
</span><span>
</span><span style="color:#c678dd;">using </span><span>WeekdayMap </span><span style="color:#c678dd;">=</span><span> std::unordered_map&lt;std::string_view, Weekday&gt;;
</span><span>WeekdayMap map </span><span style="color:#c678dd;">=</span><span> generate_map&lt;Weekday&gt;(</span><span style="color:#c678dd;">&amp;</span><span>Weekday_str);
</span><span>
</span><span>std::string current_weekday </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;monday&quot;</span><span>;
</span><span>
</span><span>WeekdayMap::iterator it </span><span style="color:#c678dd;">=</span><span> map.</span><span style="color:#e06c75;">find</span><span>(current_weekday);
</span><span style="color:#c678dd;">if </span><span>(it </span><span style="color:#c678dd;">==</span><span> map.</span><span style="color:#e06c75;">end</span><span>) {
</span><span>    </span><span style="color:#61afef;">fprintf</span><span>(stderr, </span><span style="color:#98c379;">&quot;Invalid weekday: `</span><span style="color:#e5c07b;">%s</span><span style="color:#98c379;">`</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&quot;</span><span>, current_weekday);
</span><span>} </span><span style="color:#c678dd;">else </span><span>{
</span><span>    </span><span style="color:#c678dd;">switch </span><span>(it-&gt;</span><span style="color:#e06c75;">second</span><span>) {
</span><span>        </span><span style="color:#5c6370;">// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>While this solved the problem of converting from strings to enums, it’s a bit
sluggish for general-purpose string matching. Also, this implementation still
has some problems:</p>
<ul>
<li>Problems related to the function table approach.</li>
<li>It might be better to handle invalid input in the switch case instead of
checking for iterator validity.</li>
<li>It might be better if using enums is not required.</li>
</ul>
<p>The first two problems require creating a custom hash table, so let’s solve the
third one first. To do that, instead of creating a map from string to enum
value, we can instead create a map from string to integer and type-cast it to
enum values later.</p>
<pre data-lang="diff" style="background-color:#282c34;color:#dcdfe4;" class="language-diff "><code class="language-diff" data-lang="diff"><span style="color:#e06c75;">-template&lt;typename T, uint32_t N&gt;
</span><span style="color:#98c379;">+template&lt;uint32_t N&gt;
</span><span style="color:#e06c75;">-std::unordered_map&lt;std::string_view, T&gt; generate_map(const std::string_view (*string_table)[N]) {
</span><span style="color:#98c379;">+std::unordered_map&lt;std::string_view&gt; generate_map(const std::string_view (*string_table)[N]) {
</span><span style="color:#e06c75;">- std::unordered_map&lt;std::string_view, T&gt; map;
</span><span style="color:#98c379;">+ std::unordered_map&lt;std::string_view, uint32_t&gt; map;
</span><span>  for (uint32_t i = 0; i &lt; N; ++i) {
</span><span style="color:#e06c75;">-   map.insert({(*string_table)[i], (T)i});
</span><span style="color:#98c379;">+   map.insert({(*string_table)[i], i});
</span><span>  }
</span><span>  return map;
</span><span>}
</span><span>
</span><span>...
</span><span style="color:#e06c75;">-WeekdayMap map = generate_map&lt;Weekday&gt;(&amp;Weekday_str);
</span><span style="color:#98c379;">+WeekdayMap map = generate_map(&amp;Weekday_str);
</span><span>...
</span><span>
</span><span>
</span><span>if (it == map.end) {
</span><span>    fprintf(stderr, &quot;Invalid weekday: `%s`\n&quot;, current_weekday);
</span><span>} else {
</span><span style="color:#e06c75;">-   switch (it-&gt;second) {
</span><span style="color:#98c379;">+   switch ((Weekday)it-&gt;second) {
</span><span>        // ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>Creating map to enums and map to integer both have their pros and cons, but for
the sake of generality, I decided to go with the map to integer configuration.
So in theory, we should be able to do something like this, right?</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">constexpr</span><span> std::string_view Weekday_str[] </span><span style="color:#c678dd;">= </span><span>{
</span><span>  </span><span style="color:#98c379;">&quot;monday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;tuesday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;wednesday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;thursday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;friday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;saturday&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;sunday&quot;
</span><span>};
</span><span>
</span><span>std::unordered_map&lt;std::string_view, uint32_t&gt; map </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">generate_map</span><span>(</span><span style="color:#c678dd;">&amp;</span><span>Weekday_str);
</span><span>
</span><span>std::string current_weekday </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;monday&quot;</span><span>;
</span><span style="color:#c678dd;">switch </span><span>(map[current_weekday]) {
</span><span>  </span><span style="color:#c678dd;">case</span><span> map[</span><span style="color:#98c379;">&quot;monday&quot;</span><span>]: {
</span><span>    </span><span style="color:#e06c75;">process_monday</span><span>();
</span><span>  } </span><span style="color:#c678dd;">break</span><span>;
</span><span>  </span><span style="color:#5c6370;">// ...
</span><span>}
</span></code></pre>
<p>Compiling this with Clang 18.1.8, I got:</p>
<pre style="background-color:#282c34;color:#dcdfe4;"><code><span>test.cpp:29:10: error: case value is not a constant expression
</span><span>   29 |     case map[&quot;monday&quot;]: {
</span><span>      |          ^~~~~~~~~~~~~
</span><span>test.cpp:29:10: note: non-constexpr function &#39;operator[]&#39; cannot be used in a constant expression
</span><span>/usr/bin/../lib/gcc/x86_64-redhat-linux/14/../../../../include/c++/14/bits/unordered_map.h:991:7: note: declared here
</span><span>  991 |       operator[](key_type&amp;&amp; __k)
</span><span>      |       ^
</span><span>1 error generated.
</span></code></pre>
<p>Case values needing to be known as compile time is something obvious but wasn’t
considered before. I needed a custom, compile time hash table. Compile time
hash tables effectively solves the problem of memory allocation and table
creation overhead. And a custom hash table allows me to configure it to return
invalid input as a separate, special value instead of a default value like with
<code>std::unordered_map</code>.</p>
<h1 id="implementing-a-hash-table">Implementing a hash table</h1>
<p>Dynamic arrays and hash tables are pretty ubiquitous in programming, but unlike
arrays, which have a <a href="//en.wikipedia.org/wiki/Dynamic_array">universally acceptable
implementation</a>, hash tables are
surprisingly complex and diverse, with new
<a href="//www.youtube.com/watch?v=ncHmEUmJZf4&amp;t=3s">breakthroughs</a> and
<a href="//engineering.fb.com/2019/04/25/developer-tools/f14/">innovations</a> popping up
now and then. Picking the hash function alone is an entire problem of its own;
do you want good performance, uniform distribution, or cryptographic security?
I decided to go with the FNV-1A hash function, which has decent performance and
quality. But most importantly, it’s extremely simple and <code>constexpr</code>
compatible.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">template</span><span>&lt;</span><span style="color:#c678dd;">typename</span><span> T, </span><span style="color:#c678dd;">const</span><span> T PRIME, </span><span style="color:#c678dd;">const</span><span> T BASIS&gt;
</span><span style="color:#c678dd;">constexpr</span><span> T </span><span style="color:#61afef;">fnv_1a</span><span>(</span><span style="color:#c678dd;">const char *</span><span style="color:#e06c75;">str</span><span>, uint32_t </span><span style="color:#e06c75;">len</span><span>) {
</span><span>    T h </span><span style="color:#c678dd;">=</span><span> BASIS;
</span><span>
</span><span>    </span><span style="color:#c678dd;">for </span><span>(uint32_t i </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>; i </span><span style="color:#c678dd;">&lt;</span><span> len; </span><span style="color:#c678dd;">++</span><span>i) h </span><span style="color:#c678dd;">= </span><span>(h </span><span style="color:#c678dd;">^ </span><span>(uint8_t)str[i]) </span><span style="color:#c678dd;">*</span><span> PRIME;
</span><span>    </span><span style="color:#c678dd;">for </span><span>(uint32_t t </span><span style="color:#c678dd;">=</span><span> len; t; t </span><span style="color:#c678dd;">&gt;&gt;= </span><span style="color:#e5c07b;">8</span><span>) h </span><span style="color:#c678dd;">= </span><span>(h </span><span style="color:#c678dd;">^ </span><span>(t </span><span style="color:#c678dd;">&amp; </span><span style="color:#e5c07b;">0xff</span><span>)) </span><span style="color:#c678dd;">*</span><span> PRIME;
</span><span>
</span><span>    </span><span style="color:#c678dd;">return</span><span> h;
</span><span>}
</span><span>
</span><span style="color:#c678dd;">constexpr </span><span>uint64_t </span><span style="color:#61afef;">hash64</span><span>(</span><span style="color:#c678dd;">const char *</span><span style="color:#e06c75;">str</span><span>, uint32_t </span><span style="color:#e06c75;">len</span><span>) {
</span><span>    </span><span style="color:#c678dd;">constexpr </span><span>uint64_t prime </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0x100000001b3</span><span>;
</span><span>    </span><span style="color:#c678dd;">constexpr </span><span>uint64_t basis </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">fnv_1a</span><span>&lt;uint64_t, prime, </span><span style="color:#e5c07b;">0</span><span>&gt;(</span><span style="color:#98c379;">&quot;some random seed&quot;</span><span>, </span><span style="color:#e5c07b;">16</span><span>);
</span><span>    </span><span style="color:#c678dd;">return </span><span style="color:#e06c75;">fnv_1a</span><span>&lt;uint64_t, prime, basis&gt;(str, len);
</span><span>}
</span><span>
</span><span style="color:#c678dd;">constexpr </span><span>uint32_t </span><span style="color:#61afef;">hash32</span><span>(</span><span style="color:#c678dd;">const char *</span><span style="color:#e06c75;">str</span><span>, uint32_t </span><span style="color:#e06c75;">len</span><span>) {
</span><span>    uint64_t h </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">hash64</span><span>(str, len);
</span><span>    </span><span style="color:#c678dd;">return</span><span> h </span><span style="color:#c678dd;">- </span><span>(h </span><span style="color:#c678dd;">&gt;&gt; </span><span style="color:#e5c07b;">32</span><span>);
</span><span>}
</span></code></pre>
<p>There are some modifications to the hash function that I’ve made: - The
function also hashes the bits of the length for slightly better hash quality.
The function computes its own offset basis from a given random seed string. On
64-bit machines, the difference in 32-bit and 64-bit operations is negligible,
so to compute a 32-bit hash, I computed a 64-bit hash, then combined the 32-bit
parts of the hash with a subtraction for better diffusion.</p>
<p>Is this the best hash function for this purpose? Absolutely not. The best hash
function is unique for every set of strings, called a <a href="//en.wikipedia.org/wiki/Perfect_hash_function">perfect hash
function</a>. Generating perfect
hash functions at compile time is an interesting problem that I’m sure to
investigate, but for now I’m just going to use my modified FNV-1A hash function
and focus more on the “table” part of hash tables. I’m just going to show the
code, then explain it later.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">constexpr </span><span>uint32_t </span><span style="color:#61afef;">compute_shift</span><span>(uint32_t </span><span style="color:#e06c75;">x</span><span>) {
</span><span>    uint32_t res </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">1</span><span>;
</span><span>    uint32_t shift </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">31</span><span>;
</span><span>    </span><span style="color:#c678dd;">while </span><span>(res </span><span style="color:#c678dd;">&lt;</span><span> x) {
</span><span>        res </span><span style="color:#c678dd;">&lt;&lt;= </span><span style="color:#e5c07b;">1</span><span>;
</span><span>        </span><span style="color:#c678dd;">--</span><span>shift;
</span><span>    }
</span><span>    </span><span style="color:#c678dd;">return</span><span> shift;
</span><span>}
</span><span>
</span><span style="color:#c678dd;">template</span><span>&lt;</span><span style="color:#c678dd;">const </span><span>size_t N&gt;
</span><span style="color:#c678dd;">class </span><span style="color:#e5c07b;">IndexMap {
</span><span style="color:#c678dd;">public</span><span style="color:#e5c07b;">:
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">constexpr </span><span style="color:#61afef;">IndexMap</span><span style="color:#e5c07b;">(</span><span style="color:#c678dd;">const </span><span style="color:#e5c07b;">std::</span><span style="color:#e06c75;">string_view </span><span style="color:#e5c07b;">(</span><span style="color:#c678dd;">*</span><span style="color:#e5c07b;">map)[N]) : </span><span style="color:#e06c75;">map</span><span style="color:#e5c07b;">{map}, </span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">{} {
</span><span style="color:#e5c07b;">        </span><span style="color:#c678dd;">for </span><span style="color:#e5c07b;">(uint32_t i </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0; i </span><span style="color:#c678dd;">&lt;</span><span style="color:#e5c07b;"> N; </span><span style="color:#c678dd;">++</span><span style="color:#e5c07b;">i) {
</span><span style="color:#e5c07b;">            std::string_view sv </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">(</span><span style="color:#c678dd;">*</span><span style="color:#e5c07b;">map)[i];
</span><span style="color:#e5c07b;">            uint32_t h </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">hash32</span><span style="color:#e5c07b;">(sv.</span><span style="color:#e06c75;">data</span><span style="color:#e5c07b;">(), sv.</span><span style="color:#e06c75;">size</span><span style="color:#e5c07b;">()) </span><span style="color:#c678dd;">&gt;&gt;</span><span style="color:#e5c07b;"> IndexMap::ht_shift;
</span><span style="color:#e5c07b;">            </span><span style="color:#c678dd;">while </span><span style="color:#e5c07b;">(</span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">[h]) {
</span><span style="color:#e5c07b;">                h </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">(h </span><span style="color:#c678dd;">+ </span><span style="color:#e5c07b;">1) </span><span style="color:#c678dd;">&amp; </span><span style="color:#e5c07b;">(ht_size </span><span style="color:#c678dd;">- </span><span style="color:#e5c07b;">1);
</span><span style="color:#e5c07b;">            }
</span><span style="color:#e5c07b;">            </span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">[h] </span><span style="color:#c678dd;">=</span><span style="color:#e5c07b;"> i </span><span style="color:#c678dd;">+ </span><span style="color:#e5c07b;">1;
</span><span style="color:#e5c07b;">        }
</span><span style="color:#e5c07b;">    }
</span><span style="color:#e5c07b;">
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">constexpr </span><span style="color:#e5c07b;">uint32_t </span><span style="color:#61afef;">operator[]</span><span style="color:#e5c07b;">(std::string_view </span><span style="color:#e06c75;">key</span><span style="color:#e5c07b;">) </span><span style="color:#c678dd;">const </span><span style="color:#e5c07b;">{
</span><span style="color:#e5c07b;">        uint32_t h </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">hash32</span><span style="color:#e5c07b;">(key.</span><span style="color:#e06c75;">data</span><span style="color:#e5c07b;">(), key.</span><span style="color:#e06c75;">size</span><span style="color:#e5c07b;">()) </span><span style="color:#c678dd;">&gt;&gt;</span><span style="color:#e5c07b;"> IndexMap::ht_shift;
</span><span style="color:#e5c07b;">        </span><span style="color:#c678dd;">while </span><span style="color:#e5c07b;">(</span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">[h] </span><span style="color:#c678dd;">&amp;&amp; </span><span style="color:#e5c07b;">(</span><span style="color:#c678dd;">*</span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">map</span><span style="color:#e5c07b;">)[</span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">[h] </span><span style="color:#c678dd;">- </span><span style="color:#e5c07b;">1] </span><span style="color:#c678dd;">!=</span><span style="color:#e5c07b;"> key) {
</span><span style="color:#e5c07b;">            h </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">(h </span><span style="color:#c678dd;">+ </span><span style="color:#e5c07b;">1) </span><span style="color:#c678dd;">&amp; </span><span style="color:#e5c07b;">(ht_size </span><span style="color:#c678dd;">- </span><span style="color:#e5c07b;">1);
</span><span style="color:#e5c07b;">        }
</span><span style="color:#e5c07b;">        </span><span style="color:#c678dd;">return </span><span style="color:#e06c75;">this</span><span style="color:#e5c07b;">-&gt;</span><span style="color:#e06c75;">keys</span><span style="color:#e5c07b;">[h] </span><span style="color:#c678dd;">- </span><span style="color:#e5c07b;">1;
</span><span style="color:#e5c07b;">    }
</span><span style="color:#e5c07b;">
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">static constexpr </span><span style="color:#e5c07b;">uint32_t invalid </span><span style="color:#c678dd;">= -</span><span style="color:#e5c07b;">1;
</span><span style="color:#c678dd;">private</span><span style="color:#e5c07b;">:
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">static constexpr </span><span style="color:#e5c07b;">uint32_t ht_shift </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">compute_shift</span><span style="color:#e5c07b;">(N);
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">static constexpr </span><span style="color:#e5c07b;">uint32_t ht_size </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">1 </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#e5c07b;">(32 </span><span style="color:#c678dd;">-</span><span style="color:#e5c07b;"> IndexMap::ht_shift);
</span><span style="color:#e5c07b;">
</span><span style="color:#e5c07b;">    </span><span style="color:#c678dd;">const </span><span style="color:#61afef;">std::string_view </span><span style="color:#e5c07b;">(</span><span style="color:#c678dd;">*</span><span style="color:#e06c75;">map</span><span style="color:#e5c07b;">)[N];
</span><span style="color:#e5c07b;">    uint32_t keys[IndexMap::ht_size];
</span><span style="color:#e5c07b;">}</span><span>;
</span></code></pre>
<p>The hash table is rather simple. FNV-1A has higher-quality high bits, so I
shifted the initial hash value. The table size is a power of two with values
ranging between 2N + 2 and 4N - 4, so the load factor is between 50% and 25%.
That might be a bit too low for a hash table, but I’m not going to match
against a lot of strings, so that might not be too much of an issue. Also, the
reduced load factor means that linear probing is going to be efficient due to
the shorter probe sequence length.</p>
<p>The stored indices are incremented by one, so that invalid keys are mapped to
zero, and subtracting them by one gives -1, which will be our special invalid
value. Also, you can seed that all functions, including the constructor, are
marked <code>constexpr</code>, so the hash table can be generated at compile time.
However, both the hash table and the array of strings must be stored in <a href="//en.cppreference.com/w/cpp/language/storage_duration">static
storage</a> in order to use
them at compile time, such as for switch statements.</p>
<h1 id="using-the-new-hash-table">Using the new hash table</h1>
<h2 id="general-string-matching">General string matching</h2>
<p>This is what using the static hash table for general string matching looks
like. Notice that the template parameters are automatically inferred, which is
quite convenient, but also unclear.</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">static constexpr</span><span> std::string_view Weekday_str[] </span><span style="color:#c678dd;">= </span><span>{
</span><span>  </span><span style="color:#98c379;">&quot;case 1&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;case 2&quot;</span><span>,
</span><span>  </span><span style="color:#98c379;">&quot;case 3&quot;</span><span>,
</span><span>};
</span><span>
</span><span style="color:#c678dd;">static constexpr</span><span> IndexMap map {</span><span style="color:#c678dd;">&amp;</span><span>Weekday_str};
</span><span>
</span><span>std::string input </span><span style="color:#c678dd;">= </span><span style="color:#98c379;">&quot;case 2&quot;</span><span>;
</span><span>
</span><span style="color:#c678dd;">switch </span><span>(map[input]) {
</span><span>    </span><span style="color:#c678dd;">case</span><span> map[</span><span style="color:#98c379;">&quot;case 1&quot;</span><span>]: {
</span><span>        </span><span style="color:#e06c75;">handle_case_1</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> map[</span><span style="color:#98c379;">&quot;case 2&quot;</span><span>]: {
</span><span>        </span><span style="color:#e06c75;">handle_case_2</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> map[</span><span style="color:#98c379;">&quot;case 3&quot;</span><span>]: {
</span><span>        </span><span style="color:#e06c75;">handle_case_3</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> map.</span><span style="color:#e06c75;">invalid</span><span>: {
</span><span>        </span><span style="color:#61afef;">fprintf</span><span>(stderr, </span><span style="color:#98c379;">&quot;Invalid input: `</span><span style="color:#e5c07b;">%s</span><span style="color:#98c379;">`</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&quot;</span><span>, input);
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>}
</span></code></pre>
<p>This simple hash table, while not the most efficient, satisfied all of our
requirements. It’s generated at compile time, usable as a general string
matching construct, and handling invalid input is more streamlined. However,
C++’s compile time evaluation isn’t flexible enough to do stuff such as check
if the switch cases are actually valid without doing severe metaprogramming
mental gymnastics.</p>
<h2 id="string-to-enum-conversion">String to enum conversion</h2>
<p>Using the hash table for our smaller problem of string to enum conversion is
similar, even better as you also get the benefit of compiler warning when you
missed a value. But you need to add an <code>_INVALID</code> enumerant to your enum so
that you can handle that in the switch case as well (and get warnings if you
forgot to).</p>
<pre data-lang="cpp" style="background-color:#282c34;color:#dcdfe4;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#c678dd;">enum </span><span>Weekday {
</span><span>    WEEKDAY_INVALID </span><span style="color:#c678dd;">= -</span><span style="color:#e5c07b;">1</span><span>,
</span><span>    WEEKDAY_MONDAY,
</span><span>    WEEKDAY_TUESDAY,
</span><span>    WEEKDAY_WEDNESDAY,
</span><span>    WEEKDAY_THURSDAY,
</span><span>    WEEKDAY_FRIDAY,
</span><span>    WEEKDAY_SATURDAY,
</span><span>    WEEKDAY_SUNDAY,
</span><span>    WEEKDAY_COUNT,
</span><span>};
</span><span>
</span><span style="color:#c678dd;">static constexpr</span><span> IndexMap&lt;WEEKDAY_COUNT&gt; map {</span><span style="color:#c678dd;">&amp;</span><span>Weekday_str};
</span><span>
</span><span style="color:#c678dd;">switch </span><span>(map[current_weekday]) {
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_MONDAY: {
</span><span>        </span><span style="color:#e06c75;">process_monday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_TUESDAY: {
</span><span>        </span><span style="color:#e06c75;">process_tuesday</span><span>();
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#5c6370;">// ... 
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_INVALID: {
</span><span>        </span><span style="color:#61afef;">fprintf</span><span>(stderr, </span><span style="color:#98c379;">&quot;Invalid weekday: `</span><span style="color:#e5c07b;">%s</span><span style="color:#98c379;">`</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&quot;</span><span>, current_weekday);
</span><span>    } </span><span style="color:#c678dd;">break</span><span>;
</span><span>    </span><span style="color:#c678dd;">case</span><span> WEEKDAY_COUNT: {
</span><span>        </span><span style="color:#e06c75;">__builtin_unreachable</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<h1 id="conclusion">Conclusion</h1>
<p>This post showcased my new approach to string matching and string to enum
conversion. I’m pretty happy with the solution I came up with, but there are
lots to improve upon. Some of which are:</p>
<ul>
<li>Compile time hash function generation</li>
<li>Robin Hood hashing</li>
<li>SIMD probing</li>
<li>C code generation</li>
</ul>
<p>Generalizing the hash table to enable dynamic insertion and removal at run time
might be beneficial to solve some problems. Also, I find the technique of
string to index mapping interesting; it might be useful for creating dense
associative arrays with low memory footprints and fast iteration.</p>

  </article>

      </main>

      <footer class="footer__container">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 352.5 960 188.5" preserveAspectRatio="none" class="footer__split">
  <path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#f7f9fb"/>
  <path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#eff3f7"/>
  <path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#e8eef4" stroke="#e8eef4"/>
</svg>

  <div class="footer__bg">
    <div class="footer">
      &copy; 2024 Zap (Huy-Giap Bui).
      Content on this site is licensed under <a href="//creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
    </div>

    
  </div>
</footer>

    </div>
  </body>
</html>
