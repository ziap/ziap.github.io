<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          A game I made as a course project | Zap's website
        
      
    </title><link href=/styles/fonts-critical.css rel=stylesheet><link href=/styles/fonts.css rel=stylesheet><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Zap</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">A game I made as a course project</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Tue, May 28 2024</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="2408 words"> 10 minutes read </abbr></div></div></header><article class=content__body><p>I recently programmed a large chunk of the game from scratch for a university course project. This is one of a few projects that I delivered with enough quality and presentability. So I wanted to document my process of making it, what I learned, and how I applied my knowledge from and outside the course.</p><span id=continue-reading></span><p>My university teaches “Advanced Programming Techniques and Practices” after “Introduction to Programming”. This is supposedly the next step after learning the basics of programming, as we learn mostly about dynamic memory allocation, linked lists, and how to use them to create stacks and <a href=/blog/queue/>queues</a>. At the end of the course, there’s a pair-project for us to supposedly apply the aforementioned techniques and understand their usefulness. It was fitting, as I thought they were unnecessarily compilcated and impractical, and I went into the project with hopes that this opinion would be changed.<h1 id=the-game>The game</h1><p>Before diving into the process, let’s take a look at the final result. Most of what we created is specified as required features for the project, and only some of them are actually my idea. This is what the game looks like:<figure><img alt="Screenshot of the game" src=screenshot.png><figcaption>A screenshot of the game.</figcaption></figure><p>It’s a puzzle game where you have to connect identical tiles with no more than three straight lines. Based on the project description, this is a simplified version of the <a href=//gamevui.vn/pikachu/game>Pikachu Game</a>, which is apparently a very popular game among Vietnamese students because I got called out for not knowing it. Obviously, the “Pikachu Game” is just a Pokemon-themed version of a broader type of game. After some research, I think this type of puzzle is called “Mahjong Connect”.<p>The game we created has 2 game modes, 6 levels, a tutorial, an account system, a scoring system, and a leaderboard. But most importantly, unlike my previous game projects, it actually has a user interface. There is a user flow, and regular people can actually play it. It also has sounds and animations, which drastically change how it feels and make me want to invest more time into these aspects of game development. The only downside compared to my other projects is that there is no web support. This is because I’m required to do things that make it hard to port the game to the web, such as file I/O for the account system and dynamic memory allocation. Also, because my custom OpenGL/WebGL application framework doesn’t have audio playback or font rendering (yet, hopefully). So what did I use to create the game?<h1 id=the-technologies-behind-it>The technologies behind it</h1><h2 id=programming-language>Programming language</h2><p>The game is written in C++, and compiled to both Windows and Linux. The only reason why I use C++ is that I’m required to use it. After a long period of writing C++, I’m quite tired of it. If I had full control of this project, I’d have written it in plain C and be much happier. Because I don’t like writing C++, I have to use a small subset of C that C++ supports. What I really miss are designated initializers, compound literals, and not having to type-cast the pointer returned from <code>malloc</code>. Other than that, writing C++-compatible C isn’t too bad; I just have to tell my teammate not to use C++ features. I still prefer using plain C just for the much more powerful initialization.<p>You might be wondering: without C++ features such as RAII, smart pointers and templates, how do you structure code, prevent illegal access and memory leak? How do you even write an entire game without these features? The truth is that RAII and smart pointers doesn’t fit inside my architecture. I don’t have granular, individual allocation, all resources have their lifetime tied to the scene they’re in. So resource management happens in parallel with scene management, in a controlled and predictable manner. I rarely need generic code, so the lack of template isn’t a big problem. The interface pattern, which is used extensively in scene management, is done using <a href=/blog/polymorphism#the-alternative>tagged-unions instead of polymorphism</a>.<p>I have no problem writing the game in C++-compatible C. The game is a non-trivial program with multiple scenes, objects, and resources to handle, and finishing it reinforces my idea that you don’t need much more than C.<h2 id=application-framework>Application framework</h2><p>As mentioned earlier, my custom C application framework doesn’t support audio playback or font rendering, so I decided to use an existing one. This is also a good opportunity for me to try existing frameworks and see what is missing from mine. In the spirit of using plain C, I chose raylib as the application framework for this game. It’s small, extremely easy to use, and good enough for what I’m doing. The boilerplate code is virtually nonexistent:<pre class=language-cpp data-lang=cpp style=color:#dcdfe4;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>#include </span><span style=color:#98c379>&LTraylib.h>
</span><span>
</span><span style=color:#c678dd>int </span><span style=color:#61afef>main</span><span>() {
</span><span>    </span><span style=color:#e06c75>InitWindow</span><span>(</span><span style=color:#e5c07b>1024</span><span>, </span><span style=color:#e5c07b>768</span><span>, </span><span style=color:#98c379>"App title"</span><span>);
</span><span>
</span><span>    </span><span style=color:#c678dd>while </span><span>(</span><span style=color:#c678dd>!</span><span style=color:#e06c75>WindowShouldClose</span><span>()) {
</span><span>        </span><span style=color:#e06c75>BeginDrawing</span><span>();
</span><span>        </span><span style=color:#5c6370>// Do stuff
</span><span>        </span><span style=color:#e06c75>EndDrawing</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#e06c75>CloseWindow</span><span>();
</span><span>    </span><span style=color:#c678dd>return </span><span style=color:#e5c07b>0</span><span>;
</span><span>}
</span></code></pre><p>That’s as easy as you can get. Of course, there are some design decisions by raylib that I don’t agree with. For example, the API mainly uses null terminated strings instead of slices, the user manually set up the event loop (<code>while (!WindowShouldClose())</code>), and it uses PascalCase for everything. Nonetheless, I really like its font rendering. I only used two functions, one for drawing and the other for measuring texts, and only those two are required to draw texts in any alignments or arrangements.<pre class=language-cpp data-lang=cpp style=color:#dcdfe4;background-color:#282c34><code class=language-cpp data-lang=cpp><span style=color:#c678dd>const char</span><span> text[] </span><span style=color:#c678dd>= </span><span style=color:#98c379>"Some text"</span><span>;
</span><span>
</span><span style=color:#c678dd>const int</span><span> text_width </span><span style=color:#c678dd>= </span><span style=color:#e06c75>MeasureText</span><span>(txt, size);
</span><span>
</span><span style=color:#5c6370>// Left align
</span><span style=color:#e06c75>DrawText</span><span>(text, x, y, size, color);
</span><span>
</span><span style=color:#5c6370>// Right align
</span><span style=color:#e06c75>DrawText</span><span>(text, x, w </span><span style=color:#c678dd>-</span><span> text_width, size, color);
</span><span>
</span><span style=color:#5c6370>// Center align
</span><span style=color:#e06c75>DrawText</span><span>(text, x, (w </span><span style=color:#c678dd>-</span><span> text_width) </span><span style=color:#c678dd>/ </span><span style=color:#e5c07b>2</span><span>, size, color);
</span></code></pre><p>Because the user has full control over the alignment, they can align it however they want, allowing for extremely flexible text layouts. I might adopt this API for my application framework, except with slices instead of null-terminated strings. I’m still deciding on how to render fonts; most viable option as of the time of writing is using a precomputed SDF font atlas.<p>Another extremely useful function that’s often used in conjunction with font rendering is string formatting. I used <code>snprintf</code> which is, in my opinion, one of the most useful C standard library functions. Even though it writes to null-terminated strings, it also returns the hypothetical length, which you can clamp with the maximum length to get the actual length of the resulting string. And although it’s a bit heavy, using it sparingly is okay, given that it’s as convenient as string interpolation in higher-level languages. Implementing a modified version of <code>snprintf</code> is an interesting topic for a future project.<h1 id=applied-techniques>Applied techniques</h1><p>The tech behind this game is intentionally primitive to show that you don’t need much to make a full product. Even though the project goal is simple, so that students who only passed one and a half programming courses can still make it, I think the final result is still quite complex. This is a non-exhaustive list of what we managed to implement:<ul><li>Core game logic<li>User authentication and serialization<li>Custom user interfaces written from scratch<li>A Scene management system<li>Lots of animations<li>A tutorial</ul><p>I’ll briefly talk about how we implemented the game logic, the user interface, and the animations and visuals of the game.<h2 id=core-game-logic>Core game logic</h2><p>And of course, the game logic itself is already complicated because it’s a puzzle game. I won’t go into details as this part of the game is handled by my teammate. It involves creating the data structures to represent the game, determining if a move is legal, checking if the game is over, and calculating the first legal move to use as a hint for the player. Most of it requires breadth-first search, which makes this project a perfect opportunity to use <a href=/blog/queue>my queue implementation</a>. When dequeueing, my queue returns a pointer to itself if the queue isn’t empty and a null pointer otherwise. This allows for a very cool pattern to use for BFS.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#e06c75>Queue_enqueue</span><span>(q, init);
</span><span>
</span><span style=color:#c678dd>while </span><span>(Vertex </span><span style=color:#c678dd>*</span><span>top </span><span style=color:#c678dd>= </span><span style=color:#e06c75>Queue_dequeue</span><span>(q)) {
</span><span>    Vertex v </span><span style=color:#c678dd>= *</span><span>top;
</span><span>    </span><span style=color:#5c6370>// Do something with v
</span><span>    </span><span style=color:#c678dd>for </span><span>(Vertex next </span><span style=color:#c678dd>:</span><span> v.</span><span style=color:#e06c75>edges</span><span>) {
</span><span>        </span><span style=color:#e06c75>Queue_enqueue</span><span>(q, item);
</span><span>    }
</span><span>}                
</span></code></pre><p>Because this is my own queue implementation, I got to do whatever I wanted and using pointers as a return type instead of an iterator or a proper optional type. In my opinion, pointers are good enough for “optional reference”, and creating a custom optional type or even using <code>std::optional</code> is useless because C++ isn’t built with them in mind, and there’s no control flow to make working with them less painful. Also I don’t care about iterators. But what about invalidation? Just dereference the pointer before modifying the queue.<h2 id=the-user-interface>The user interface</h2><p>Unlike the game logic, where my contribution ended with the queue, I worked a lot on the user interface and animation system. When working on the interface, the <a href=//en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller>MVC pattern</a> naturally came up; however, all the data for the UI and game states are stored in a single massive struct. I’m not ashamed of doing that, as it was still fairly easy to work with, and I didn’t have to think about some form of elaborated state management scheme. I’m super grateful that I worked with HTML and CSS and understood the fundamentals of designing responsive layouts without worrying about the technical details. Because of that, I was able to implement the UI for the game from scratch with specific requirements that match what I knew. I might consider doing more higher-level stuff to better understand the requirements of lower-level systems.<p>UIs are somewhat daunting to tackle, as there are tons and tons of cases to consider. How to handle focus or hover, how to edit text boxes with keyboard inputs, how to implement checkboxes, radio buttons, and millions of other types of widgets. And most importantly, how to implement them in a way that’s correct, extensible, maintainable, and performant. But a basic UI is really not that hard, and game UIs have a much more relaxed set of requirements than general UIs.<p>I haven’t written UI before because they require font rendering, which I have yet to implement, and also because I was daunted, and writing them seems like a chore compared to the other more exciting game logic stuffs. I’m glad that this time I decided to let my teammate work on the game logic while I learned how to write the UIs for the game. After the project, I now know how to write UIs, the results are basic but not too bad.<h2 id=game-visuals>Game visuals</h2><p>This is the part that I’m extremely proud of. It’s one of the rare instances where I find the results more interesting than the technical details. I feel like my process of learning graphics programming finally paid off. The color palette of the game is procedurally generated using <a href=//iquilezles.org/articles/palettes/>this technique</a>. It’s designed to generate color in real time, usually on the GPU, as it avoids the complex process of color space conversion. But that process usually results in better and more visually uniform colors.<figure><img alt="The color palette" src=palette.png><figcaption>The generated color palette.</figcaption></figure><p>I’m also happy with the animation of the game. It’s something that I can’t effectively show in a blog post, so you have to play the game to see it for yourself. It’s implemented using a basic interpolation system, with some smoothing functions to make them, well, smoother. What I struggled with was how to integrate the animation into the game update loop. After a while, I managed to figure out a good framework for doing it. However, I’m not really happy about the method and might consider trying out more animation systems.<h2 id=course-related-techniques>Course-related techniques</h2><p>The purpose of the project is to show the difference between arrays and linked lists, and my teammate took care of that. I didn’t care too much about that; linked lists have their usages, but efficiently representing the game is not one of those. Using heap allocation for arrays is also one of the requirements for the project, which is also somewhat unreasonable. Of course, to store the player data a heap allocated array makes lots of sense, but for the game board, it’s kind of dumb. The size of the game board varies between levels, but the upper bound is already known at compile time, and it’s small enough to just store them using static global arrays. I don’t plan on having multiple games running simultaneously, I don’t plan on having boards that are bigger than the limit. So in my opinion, the heap allocation and, subsequently, the resource management aren’t worth it. To make it easier to manage the resource and improve performance, I used the following trick to make a 2D array with a single allocation:<figure><img alt="Pointer diagram for the 2D array allocation" src=2d-array.svg><figcaption>Visual example of this technique allocating a 3x3 array</figcaption></figure><p>Although I still had to set the pointers to the correct rows, it’s still one allocation instead of the number of rows, and the entire array can be freed at once. A better solution is to use a 1D array and use <code>a[w * y + x]</code> to index into it, but the algorithms my teammate developed rely too much on 2D indices, so using double indirection (but not double allocation) is still preferable. This method has the extra benefit of <code>O(h)</code> row deletion as opposed to <code>O(wh)</code> for 1D array representation. It’s cool, right, but remember that I only had to do this because I can’t use static global arrays, which is even more efficient. We learned about heap allocation so that we can have arrays that are not limited at compile time. But I think that we are tought to over-rely too much on it, and it’s better to think about our constraints and avoid them as much as we can.<h1 id=closing>Closing</h1><p>Overall, I enjoyed working on the project, and learned many things, most of which are not related to the course and might be considered redundant. There’s no requirement to implement UI or animations, but I implemented them nonetheless because I wanted to learn how to do them and I decided that having them was important for the final product. The final result is not as good as it could be, but for the constraints and time limit that we were given, I’m pretty happy with how it turned out. I might consider going back to this and making some improvements, the most essential of which are particle systems and WebAssembly support. But right now, I have a clearer vision for what is needed for an application framework, so I’ll spend time and effort developing my own.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Zap (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>