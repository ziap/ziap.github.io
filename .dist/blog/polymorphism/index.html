<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bui Huy Giap&#x27;s personal website and blog">
    <title>
      
        
          A faster, more flexible alternative to run-time polymorphism in C++ feat. Rust |
        

        Zap&#x27;s website
      
    </title>
    <link rel="stylesheet" href="/styles/base.css">
    <link rel="stylesheet" href="/styles/nav.css">
    <link rel="stylesheet" href="/styles/footer.css">
    <link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS">
    
  

  <link rel="stylesheet" href="/styles/page.css">

  </head>
  <body>
    
      <div class="nav__bg">
        <div class="nav__container">
          

<nav class="nav">
  <h3 class="nav__title">
    <a href="/" class="nav__title__link">Zap</a>
  </h3>
  <ul class="nav__links">
    
      <li><a class="nav__link" href="/works">Works</a></li>
    
      <li><a class="nav__link" href="/blog">Blog</a></li>
    
      <li><a class="nav__link" href="/about">About</a></li>
    
  </ul>
</nav>

        </div>
      </div>
    

    <div class="container">
      <main class="content">
        
  
  <header class="post-header">
    
    <h1 class="post-header__title title">A faster, more flexible alternative to run-time polymorphism in C++ feat. Rust</h1>
    
    
      <div class="post-header__meta">
        <div class="post-header__data">
          
  <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512">
  <!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
  <path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/>
</svg>


          Sat, Feb 10 2024
        </div>

        <div class="post-header__data">
          
  <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512">
  <!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
  <path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/>
</svg>


          
  
  

  13
  
    minutes
  
  read

        </div>
      </div>
    
  </header>


  <article class="content__body">
    <p>When I first heard about run-time polymorphism in C++ using virtual methods, my
first thoughts were like, “This is cool and all, but why would I ever use
this?” Then I continued to ignore it because I could always just work around it
instead of using it. Until recently, my college lecturer told me that using
virtual methods is great for designing and maintaining applications with
thousands of objects. I figured that I should write about what run-time
polymorphism is, and why I still think that I don’t need it.</p>
<span id="continue-reading"></span><h1 id="a-brief-introduction-to-polymorphism-in-c">A brief introduction to polymorphism in C++</h1>
<p>Polymorphism means “many-forms”, and in programming, it means designing an API
that works with multiple “forms” of input, for example, a function that takes
multiple data-type. Consider the following function:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">template</span><span>&lt;</span><span style="color:#c678dd;">class</span><span> T1, T2&gt;
</span><span style="color:#c678dd;">double </span><span style="color:#61afef;">add_area</span><span>(T1 </span><span style="color:#e06c75;">shape1</span><span>, T2 </span><span style="color:#e06c75;">shape2</span><span>) {
</span><span>  </span><span style="color:#c678dd;">return</span><span> shape1.</span><span style="color:#e06c75;">area</span><span>() </span><span style="color:#c678dd;">+</span><span> shape2.</span><span style="color:#e06c75;">area</span><span>();
</span><span>}
</span></code></pre>
<p>This function is polymorphic because it works with any data-type with a member
function <code>area</code>. However, the template arguments <code>T1</code> and <code>T2</code> needs to be
determined at compile-time, so we only achieved compile-time polymorphism.
Run-time polymorphism is a bit complicated:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">class </span><span style="color:#e5c07b;">Shape {
</span><span style="color:#c678dd;">public</span><span style="color:#e5c07b;">:
</span><span style="color:#e5c07b;">  </span><span style="color:#61afef;">Shape</span><span style="color:#e5c07b;">() {}
</span><span style="color:#e5c07b;">  
</span><span style="color:#e5c07b;">  </span><span style="color:#c678dd;">virtual double </span><span style="color:#61afef;">area</span><span style="color:#e5c07b;">() </span><span style="color:#c678dd;">const = </span><span style="color:#e5c07b;">0;
</span><span style="color:#e5c07b;">  </span><span style="color:#c678dd;">virtual </span><span style="color:#61afef;">~Shape</span><span style="color:#e5c07b;">() </span><span style="color:#c678dd;">= default</span><span style="color:#e5c07b;">;
</span><span style="color:#e5c07b;">}</span><span>;
</span><span>
</span><span style="color:#c678dd;">double </span><span style="color:#61afef;">add_area</span><span>(Shape </span><span style="color:#c678dd;">*</span><span style="color:#e06c75;">shape1</span><span>, Shape </span><span style="color:#c678dd;">*</span><span style="color:#e06c75;">shape2</span><span>) {
</span><span>  </span><span style="color:#c678dd;">return</span><span> shape1-&gt;</span><span style="color:#e06c75;">area</span><span>() </span><span style="color:#c678dd;">+</span><span> shape2-&gt;</span><span style="color:#e06c75;">area</span><span>();
</span><span>}
</span></code></pre>
<p>The <code>Shape</code> class is called an “abstract” class, which means that it can’t be
allocated and can only serves as an interface for other classes to inherit
from. Which means that the function <code>add_area</code> takes two pointers that point to
two arbitrary objects that inherits from the <code>Shape</code> class. What makes this
different from the previous example is that this is an actual function, not a
template, and the objects that those pointers point to are determined at
run-time, not at compile-time.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>Shape </span><span style="color:#c678dd;">*</span><span>shape1 </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">random_bool</span><span>() </span><span style="color:#c678dd;">? new </span><span style="color:#e06c75;">Square</span><span>(</span><span style="color:#e5c07b;">4</span><span>) </span><span style="color:#c678dd;">: new </span><span style="color:#e06c75;">Circle</span><span>(</span><span style="color:#e5c07b;">2</span><span>);
</span><span>Shape </span><span style="color:#c678dd;">*</span><span>shape2 </span><span style="color:#c678dd;">= </span><span style="color:#e06c75;">random_bool</span><span>() </span><span style="color:#c678dd;">? new </span><span style="color:#e06c75;">Square</span><span>(</span><span style="color:#e5c07b;">4</span><span>) </span><span style="color:#c678dd;">: new </span><span style="color:#e06c75;">Circle</span><span>(</span><span style="color:#e5c07b;">2</span><span>);
</span><span>
</span><span>std::cout </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#e06c75;">add_area</span><span>(shape1, shape2) </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#98c379;">&#39;</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&#39;</span><span>;
</span><span>
</span><span style="color:#c678dd;">delete</span><span> shape1;
</span><span style="color:#c678dd;">delete</span><span> shape2;
</span></code></pre>
<h1 id="a-simple-example">A simple example</h1>
<p>Run-time polymorphism is often used when the data-type is not known at compile
time. Maybe the users want to select what type of shape to add the area
together. Let’s extend the previous example to include run-time data. You have
to import the shapes from a file. For demonstration purposes, the file format
is extremely simple. It’s a text file with every line containing a string
representing the shape type, and floating point numbers representing the shape
attributes. The shape types, their attributes and how to compute the area are
described in the table below:</p>
<table><thead><tr><th>shape type</th><th>attributes</th><th>area formula</th></tr></thead><tbody>
<tr><td>“square”</td><td>side</td><td>side * side</td></tr>
<tr><td>“rectangle”</td><td>width, height</td><td>width * height</td></tr>
<tr><td>“circle”</td><td>radius</td><td>radius * radius * PI</td></tr>
<tr><td>“triangle”</td><td>3 sides</td><td>Heron’s formula<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://en.wikipedia.org/wiki/Heron&#x27;s_formula">https://en.wikipedia.org/wiki/Heron's_formula</a></p>
</div>
<p>We can’t tell what shape they are until we have read the file at run-time. So
to get the total area of the entire file, we need a run-time polymorphic
function:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">double </span><span style="color:#61afef;">total_area</span><span>(Shape </span><span style="color:#c678dd;">**</span><span style="color:#e06c75;">shapes</span><span>, size_t </span><span style="color:#e06c75;">shapes_len</span><span>) {
</span><span>  </span><span style="color:#c678dd;">double</span><span> result </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>
</span><span>  </span><span style="color:#c678dd;">for </span><span>(size_t i </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>; i </span><span style="color:#c678dd;">&lt;</span><span> shapes_len; </span><span style="color:#c678dd;">++</span><span>i) {
</span><span>    result </span><span style="color:#c678dd;">+=</span><span> shapes[i]-&gt;</span><span style="color:#e06c75;">area</span><span>();
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>The <code>Shape</code> class is the same as the above, but notice that we need double
pointer indirection, because every shape in the array is still a pointer to the
actual non-abstract shape. This means that every single shape is allocated
individually on the heap, which is pretty expensive, and you can mess up if
you’re not careful. So instead of using raw pointers, in the spirit of C++,
here is a safer and potentially faster version of the previous function:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">double </span><span style="color:#61afef;">total_area</span><span>(std::span&lt;std::unique_ptr&lt;Shape&gt;&gt; </span><span style="color:#e06c75;">shapes</span><span>) {
</span><span>  </span><span style="color:#c678dd;">double</span><span> result </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>
</span><span>  </span><span style="color:#c678dd;">for </span><span>(std::unique_ptr&lt;Shape&gt; </span><span style="color:#c678dd;">&amp;</span><span>shape </span><span style="color:#c678dd;">:</span><span> shapes) {
</span><span>    result </span><span style="color:#c678dd;">+=</span><span> shape-&gt;</span><span style="color:#e06c75;">area</span><span>();
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>It’s arguably uglier, but the <code>std::unique_ptr</code> saves us from the hassle of
cleaning up memory, and since we’re using smart pointers anyways, I’m throwing
in <code>std::span</code>—a new C++20 feature—as well so we don’t have to pass in
the length, we can use the range-based for loop for iteration, and the function
automatically works with <code>std::vector</code>s.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; shapes;
</span><span>
</span><span>shapes.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Square&gt;(</span><span style="color:#e5c07b;">4</span><span>));
</span><span>shapes.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Circle&gt;(</span><span style="color:#e5c07b;">2</span><span>));
</span><span>shapes.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Rectangle&gt;(</span><span style="color:#e5c07b;">3</span><span>, </span><span style="color:#e5c07b;">4</span><span>));
</span><span>shapes.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Triangle&gt;(</span><span style="color:#e5c07b;">3</span><span>, </span><span style="color:#e5c07b;">4</span><span>, </span><span style="color:#e5c07b;">5</span><span>));
</span><span>
</span><span>std::cout </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#e06c75;">total_area</span><span>(shapes) </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#98c379;">&#39;</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&#39;</span><span>; </span><span style="color:#5c6370;">// 46.566370614359172
</span></code></pre>
<p>This is great! It automatically figures out how to compute the area for every
shape that we throw at it. We don’t need to manually handle every single case,
and even though the shapes are heap allocated <code>std::unique_ptr</code>, makes working
with them less painful. Also, notice how I didn’t show a single line of code on
how to compute the area, because with polymorphism, it actually doesn’t matter.
But currently we still hard-code the shapes, so this is possible even with
compile-time polymorphism. So let’s justify this by importing the shapes from
the file.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">enum class </span><span>ShapeTypes {
</span><span>  SQUARE,
</span><span>  RECTANGLE,
</span><span>  CIRCLE,
</span><span>  TRIANGLE
</span><span>};
</span><span>
</span><span style="color:#c678dd;">static const</span><span> std::unordered_map&lt;std::string_view, ShapeTypes&gt; shape_map </span><span style="color:#c678dd;">= </span><span>{
</span><span>  {</span><span style="color:#98c379;">&quot;square&quot;</span><span>, ShapeTypes::SQUARE},
</span><span>  {</span><span style="color:#98c379;">&quot;rectangle&quot;</span><span>, ShapeTypes::RECTANGLE},
</span><span>  {</span><span style="color:#98c379;">&quot;circle&quot;</span><span>, ShapeTypes::CIRCLE},
</span><span>  {</span><span style="color:#98c379;">&quot;triangle&quot;</span><span>, ShapeTypes::TRIANGLE}
</span><span>};
</span><span>
</span><span>std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; </span><span style="color:#61afef;">get_shapes</span><span>(</span><span style="color:#c678dd;">const char *</span><span style="color:#e06c75;">file_path</span><span>) {
</span><span>  std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; result;
</span><span>  std::ifstream </span><span style="color:#e06c75;">fin</span><span>(file_path);
</span><span>
</span><span>  </span><span style="color:#c678dd;">char</span><span> type_str[</span><span style="color:#e5c07b;">16</span><span>];
</span><span>
</span><span>  </span><span style="color:#c678dd;">while </span><span>(fin </span><span style="color:#c678dd;">&gt;&gt;</span><span> type_str) {
</span><span>    </span><span style="color:#c678dd;">switch </span><span>(shape_map.</span><span style="color:#e06c75;">find</span><span>(type_str)-&gt;</span><span style="color:#e06c75;">second</span><span>) {
</span><span>      </span><span style="color:#c678dd;">case</span><span> ShapeTypes::SQUARE: {
</span><span>        </span><span style="color:#c678dd;">double</span><span> side;
</span><span>        fin </span><span style="color:#c678dd;">&gt;&gt;</span><span> side;
</span><span>        result.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Square&gt;(side));
</span><span>        </span><span style="color:#c678dd;">break</span><span>;
</span><span>      }
</span><span>      </span><span style="color:#c678dd;">case</span><span> ShapeTypes::RECTANGLE: {
</span><span>        </span><span style="color:#c678dd;">double</span><span> width, height;
</span><span>        fin </span><span style="color:#c678dd;">&gt;&gt;</span><span> width </span><span style="color:#c678dd;">&gt;&gt;</span><span> height;
</span><span>        result.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Rectangle&gt;(width, height));
</span><span>        </span><span style="color:#c678dd;">break</span><span>;
</span><span>      }
</span><span>      </span><span style="color:#c678dd;">case</span><span> ShapeTypes::CIRCLE: {
</span><span>        </span><span style="color:#c678dd;">double</span><span> radius;
</span><span>        fin </span><span style="color:#c678dd;">&gt;&gt;</span><span> radius;
</span><span>        result.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Circle&gt;(radius));
</span><span>        </span><span style="color:#c678dd;">break</span><span>;
</span><span>      }
</span><span>      </span><span style="color:#c678dd;">case</span><span> ShapeTypes::TRIANGLE: {
</span><span>        </span><span style="color:#c678dd;">double</span><span> side1, side2, side3;
</span><span>        fin </span><span style="color:#c678dd;">&gt;&gt;</span><span> side1 </span><span style="color:#c678dd;">&gt;&gt;</span><span> side2 </span><span style="color:#c678dd;">&gt;&gt;</span><span> side3;
</span><span>        result.</span><span style="color:#e06c75;">push_back</span><span>(std::</span><span style="color:#e06c75;">make_unique</span><span>&lt;Triangle&gt;(side1, side2, side3));
</span><span>        </span><span style="color:#c678dd;">break</span><span>;
</span><span>      }
</span><span>    }
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>Okay, now it’s no longer pretty. We tried so hard not to write the code that
handles different shape types, but now, when reading the file, we can’t avoid
writing it. But if we don’t import the shape from the files dynamically at
run-time, then it’s the same as compile-time polymorphism. Also, if we want to
tweak the function, like, for example: “Get the total area of all circles and
triangles”, we need to update the abstract class to expose more information:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">class </span><span style="color:#e5c07b;">Shape {
</span><span style="color:#c678dd;">public</span><span style="color:#e5c07b;">:
</span><span style="color:#e5c07b;">  </span><span style="color:#61afef;">Shape</span><span style="color:#e5c07b;">() {}
</span><span style="color:#e5c07b;">  
</span><span style="color:#e5c07b;">  </span><span style="color:#c678dd;">virtual double </span><span style="color:#61afef;">area</span><span style="color:#e5c07b;">() </span><span style="color:#c678dd;">const = </span><span style="color:#e5c07b;">0;
</span><span style="color:#e5c07b;">  </span><span style="color:#c678dd;">virtual double </span><span style="color:#61afef;">is_circle_or_triangle</span><span style="color:#e5c07b;">() </span><span style="color:#c678dd;">const = </span><span style="color:#e5c07b;">0;
</span><span style="color:#e5c07b;">  </span><span style="color:#c678dd;">virtual </span><span style="color:#61afef;">~Shape</span><span style="color:#e5c07b;">() </span><span style="color:#c678dd;">= default</span><span style="color:#e5c07b;">;
</span><span style="color:#e5c07b;">}</span><span>;
</span><span>
</span><span style="color:#c678dd;">double </span><span style="color:#61afef;">total_area_circles_and_triangles</span><span>(std::span&lt;std::unique_ptr&lt;Shape&gt;&gt; </span><span style="color:#e06c75;">shapes</span><span>) {
</span><span>  </span><span style="color:#c678dd;">double</span><span> result </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>
</span><span>  </span><span style="color:#c678dd;">for </span><span>(std::unique_ptr&lt;Shape&gt; </span><span style="color:#c678dd;">&amp;</span><span>shape </span><span style="color:#c678dd;">:</span><span> shapes) {
</span><span>    </span><span style="color:#c678dd;">if </span><span>(shape-&gt;</span><span style="color:#e06c75;">is_circle_or_triangle</span><span>()) {
</span><span>      result </span><span style="color:#c678dd;">+=</span><span> shape-&gt;</span><span style="color:#e06c75;">area</span><span>();
</span><span>    }
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>Then we need to manually implement the new method for all shapes. So while
run-time polymorphism sounds great on paper, it falls apart when you actually
write the entire system that operates at run-time. What really changed is that
run-time polymorphism hides away the difficulty of maintaining multiple types
of data in some places. It might be useful in certain circumstances, but the
difficulty is still there.</p>
<h1 id="the-alternative">The alternative</h1>
<p>The most obvious solution is to just read the file, process it, and compute the
total area immediately. But let’s pretend that we absolutely have to store the
data into an array first, and perform the computation on the stored array.
Maybe we want to do something else with the array other than doing the
computation. So, how do we store multiple shapes in the same array without
run-time polymorphism? The answer is to use a data structure known as a tagged
union. There are <code>std::variant</code> in C++, but I think that it’s more convenient
to just literally use a tag and a union. In fact, this structure is so simple
that you don’t even need any of C++’s features and just write it in plain C.
The only C++ feature I use right now (other than member functions) is <code>enum class</code> only because it is scoped and because I’m in C++ anyways.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">struct </span><span>Shape {
</span><span>  </span><span style="color:#c678dd;">enum class </span><span>Types {
</span><span>    SQUARE,
</span><span>    RECTANGLE,
</span><span>    CIRCLE,
</span><span>    TRIANGLE
</span><span>  };
</span><span>
</span><span>  Types tag;
</span><span>
</span><span>  </span><span style="color:#c678dd;">union </span><span>{
</span><span>    </span><span style="color:#c678dd;">struct </span><span>{
</span><span>      </span><span style="color:#c678dd;">double</span><span> side;
</span><span>    } square;
</span><span>
</span><span>    </span><span style="color:#c678dd;">struct </span><span>{
</span><span>      </span><span style="color:#c678dd;">double</span><span> width, height;
</span><span>    } rectangle;
</span><span>
</span><span>    </span><span style="color:#c678dd;">struct </span><span>{
</span><span>      </span><span style="color:#c678dd;">double</span><span> radius;
</span><span>    } circle;
</span><span>
</span><span>    </span><span style="color:#c678dd;">struct </span><span>{
</span><span>      </span><span style="color:#c678dd;">double</span><span> sides[</span><span style="color:#e5c07b;">3</span><span>];
</span><span>    } triangle;
</span><span>
</span><span>    </span><span style="color:#c678dd;">double</span><span> attrs[</span><span style="color:#e5c07b;">0</span><span>];
</span><span>  };
</span><span>
</span><span>  </span><span style="color:#c678dd;">double </span><span style="color:#61afef;">area</span><span>() </span><span style="color:#c678dd;">const </span><span>{
</span><span>    </span><span style="color:#c678dd;">switch </span><span>(tag) {
</span><span>      </span><span style="color:#c678dd;">case</span><span> Types::SQUARE: </span><span style="color:#c678dd;">return</span><span> square.</span><span style="color:#e06c75;">side </span><span style="color:#c678dd;">*</span><span> square.</span><span style="color:#e06c75;">side</span><span>;
</span><span>      </span><span style="color:#c678dd;">case</span><span> Types::RECTANGLE: </span><span style="color:#c678dd;">return</span><span> rectangle.</span><span style="color:#e06c75;">width </span><span style="color:#c678dd;">*</span><span> rectangle.</span><span style="color:#e06c75;">height</span><span>;
</span><span>      </span><span style="color:#c678dd;">case</span><span> Types::CIRCLE: </span><span style="color:#c678dd;">return</span><span> circle.</span><span style="color:#e06c75;">radius </span><span style="color:#c678dd;">*</span><span> circle.</span><span style="color:#e06c75;">radius </span><span style="color:#c678dd;">*</span><span> M_PI;
</span><span>      </span><span style="color:#c678dd;">case</span><span> Types::TRIANGLE: {
</span><span>        </span><span style="color:#c678dd;">const double *</span><span>sides </span><span style="color:#c678dd;">=</span><span> triangle.</span><span style="color:#e06c75;">sides</span><span>;
</span><span>        </span><span style="color:#c678dd;">const double</span><span> s </span><span style="color:#c678dd;">= </span><span>(sides[</span><span style="color:#e5c07b;">0</span><span>] </span><span style="color:#c678dd;">+</span><span> sides[</span><span style="color:#e5c07b;">1</span><span>] </span><span style="color:#c678dd;">+</span><span> sides[</span><span style="color:#e5c07b;">2</span><span>]) </span><span style="color:#c678dd;">* </span><span style="color:#e5c07b;">0.5</span><span>;
</span><span>
</span><span>        </span><span style="color:#c678dd;">return </span><span style="color:#61afef;">sqrt</span><span>(s </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> sides[</span><span style="color:#e5c07b;">0</span><span>]) </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> sides[</span><span style="color:#e5c07b;">1</span><span>]) </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> sides[</span><span style="color:#e5c07b;">2</span><span>]));
</span><span>      }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#e06c75;">__builtin_unreachable</span><span>();
</span><span>  }
</span><span>};
</span></code></pre>
<p>Before, we did’t have to care about how the shapes were implemented but now we
do because it’s no longer hidden behind abstract classes and virtual methods.
Remember, they’re hidden and abstracted away, but they’re still there. I think
that the code that computes the area in every derived class is the same as the
same code, but in the switch cases. It feels like we have to manually handle
different shapes in the <code>area</code> method. But as we saw before, manually handling
different cases is inevitable at run-time, so I don’t think there’s a good
reason to avoid it. You might wonder: “What happens when you add a new shape?”.
Well, just add a new shape to the enum and the compiler will emit a warning
that you haven’t handled all enum values. Constructing a shape is also simple
with designated initializers.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span>Shape square </span><span style="color:#c678dd;">= </span><span>{
</span><span>  .</span><span style="color:#e06c75;">type </span><span style="color:#c678dd;">=</span><span> Shape::Types::SQUARE,
</span><span>  .</span><span style="color:#e06c75;">square </span><span style="color:#c678dd;">= </span><span>{
</span><span>    .</span><span style="color:#e06c75;">side </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">4
</span><span>  }
</span><span>};
</span><span>
</span><span>Shape triangle </span><span style="color:#c678dd;">= </span><span>{
</span><span>  .</span><span style="color:#e06c75;">type </span><span style="color:#c678dd;">=</span><span> Shape::Types::TRIANGLE,
</span><span>  .</span><span style="color:#e06c75;">triangle </span><span style="color:#c678dd;">= </span><span>{
</span><span>    .</span><span style="color:#e06c75;">sides </span><span style="color:#c678dd;">= </span><span>{</span><span style="color:#e5c07b;">3</span><span>, </span><span style="color:#e5c07b;">4</span><span>, </span><span style="color:#e5c07b;">5</span><span>}
</span><span>  }
</span><span>};
</span></code></pre>
<p>You can even use a factory function to simplify the creation of shapes, but I
think that designated initializers are good enough. One of the downsides of
this approach is reduced type safety. There’s nothing preventing you from
accessing the radius of a square. If you know your union, then it’s fine. But
mistakes can happen, and this is one place where you can mess up. Now <code>Shape</code>
is an actual class, its instances <em>are</em> shapes and not pointers pointing to the
actual shape. This effectively removes one level of indirection, so all shapes
can be in the same contiguous memory region.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">double </span><span style="color:#61afef;">total_area</span><span>(std::span&lt;Shape&gt; </span><span style="color:#e06c75;">shapes</span><span>) {
</span><span>  </span><span style="color:#c678dd;">double</span><span> result </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>  
</span><span>  </span><span style="color:#c678dd;">for </span><span>(Shape </span><span style="color:#c678dd;">&amp;</span><span>shape </span><span style="color:#c678dd;">:</span><span> shapes) {
</span><span>    result </span><span style="color:#c678dd;">+=</span><span> shape.</span><span style="color:#e06c75;">area</span><span>();
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>Now we don’t have to worry about cleaning up individual shape, or even have to
use <code>std::unique_ptr</code>, and it might even help with performance! But before
that, let’s see how do we import the shapes from the file.</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">static const</span><span> std::unordered_map&lt;std::string_view, Shape::Types&gt; shape_map </span><span style="color:#c678dd;">= </span><span>{
</span><span>  {</span><span style="color:#98c379;">&quot;square&quot;</span><span>, Shape::Types::SQUARE},
</span><span>  {</span><span style="color:#98c379;">&quot;rectangle&quot;</span><span>, Shape::Types::RECTANGLE},
</span><span>  {</span><span style="color:#98c379;">&quot;circle&quot;</span><span>, Shape::Types::CIRCLE},
</span><span>  {</span><span style="color:#98c379;">&quot;triangle&quot;</span><span>, Shape::Types::TRIANGLE}
</span><span>};
</span><span>
</span><span>std::vector&lt;Shape&gt; </span><span style="color:#61afef;">read_file</span><span>(</span><span style="color:#c678dd;">const char *</span><span style="color:#e06c75;">file_path</span><span>) {
</span><span>  std::vector&lt;Shape&gt; result;
</span><span>  std::ifstream </span><span style="color:#e06c75;">fin</span><span>(file_path);
</span><span>
</span><span>  std::string line;
</span><span>
</span><span>  </span><span style="color:#c678dd;">while </span><span>(std::</span><span style="color:#e06c75;">getline</span><span>(fin, line)) {
</span><span>    std::stringstream </span><span style="color:#e06c75;">ss</span><span>(line);
</span><span>    </span><span style="color:#c678dd;">char</span><span> type_str[</span><span style="color:#e5c07b;">16</span><span>];
</span><span>    ss </span><span style="color:#c678dd;">&gt;&gt;</span><span> type_str;
</span><span>
</span><span>    Shape shape;
</span><span>    shape.</span><span style="color:#e06c75;">tag </span><span style="color:#c678dd;">=</span><span> shape_map.</span><span style="color:#e06c75;">find</span><span>(type_str)-&gt;</span><span style="color:#e06c75;">second</span><span>;
</span><span>    
</span><span>    size_t attrs_len </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>    </span><span style="color:#c678dd;">double</span><span> attr;
</span><span>    </span><span style="color:#c678dd;">while </span><span>(ss </span><span style="color:#c678dd;">&gt;&gt;</span><span> attr) shape.</span><span style="color:#e06c75;">attrs</span><span>[attrs_len</span><span style="color:#c678dd;">++</span><span>] </span><span style="color:#c678dd;">=</span><span> attr;
</span><span>
</span><span>    result.</span><span style="color:#e06c75;">push_back</span><span>(shape);
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>This, in my opinion, is even nicer than the previous implementation. We already
have the <code>Shape::Types</code> enum for the tag, so we can easily reuse it here.
Remember <code>double attrs[0]</code>? It’s an array representing the underlying values of
the shape attributes. Because the file is already in the correct order, we can
just push items into that array instead of matching the shape type and
constructing the correct shape. So by having more control over the memory
layout, we can analyze and reduce some repetition. What about the example of
only adding the area of circles and triangles? It’s just a single if statement:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#c678dd;">double </span><span style="color:#61afef;">total_area_circles_and_triangles</span><span>(std::span&lt;Shape&gt; </span><span style="color:#e06c75;">shapes</span><span>) {
</span><span>  </span><span style="color:#c678dd;">double</span><span> result </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0</span><span>;
</span><span>  
</span><span>  </span><span style="color:#c678dd;">for </span><span>(Shape </span><span style="color:#c678dd;">&amp;</span><span>shape </span><span style="color:#c678dd;">:</span><span> shapes) {
</span><span>    </span><span style="color:#c678dd;">if </span><span>(shape.</span><span style="color:#e06c75;">tag </span><span style="color:#c678dd;">==</span><span> Shape::Types::CIRCLE </span><span style="color:#c678dd;">||</span><span> shape.</span><span style="color:#e06c75;">tag </span><span style="color:#c678dd;">==</span><span> Shape::Types::TRIANGLE) {
</span><span>      result </span><span style="color:#c678dd;">+=</span><span> shape.</span><span style="color:#e06c75;">area</span><span>();
</span><span>    }
</span><span>  }
</span><span>
</span><span>  </span><span style="color:#c678dd;">return</span><span> result;
</span><span>}
</span></code></pre>
<p>You don’t need to edit all the shapes just to add that. So by not avoiding
handling different shapes manually, we increased the flexibility of our code,
and sometimes adding features is easier because of it.</p>
<h1 id="bonus-content-polymorphism-and-tagged-union-in-rust">Bonus content: Polymorphism and Tagged union in Rust</h1>
<p>If you are not interested, feel free to skip to the
<a href="https://ziap.github.io/blog/polymorphism/#benchmark-and-conclusion">benchmark</a>.</p>
<h2 id="polymorphism-using-trait">Polymorphism using Trait</h2>
<p>So that’s about C++, but what about polymorphism in other languages? In Rust,
methods and other shared behaviors are defined using Trait instead of
inheritance. For example, instead of <code>Square</code> and <code>Circle</code> inheriting <code>Shape</code>,
they instead have the trait <code>Area</code>.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">trait </span><span>Area {
</span><span>  </span><span style="color:#c678dd;">fn </span><span style="color:#61afef;">area</span><span>(</span><span style="color:#c678dd;">&amp;</span><span style="color:#e06c75;">self</span><span>) -&gt; </span><span style="color:#c678dd;">f64</span><span>;
</span><span>}
</span><span>
</span><span style="color:#c678dd;">struct </span><span>Square {
</span><span>  </span><span style="color:#e06c75;">side</span><span>: </span><span style="color:#c678dd;">f64
</span><span>}
</span><span>
</span><span style="color:#c678dd;">impl </span><span>Area </span><span style="color:#c678dd;">for </span><span>Square {
</span><span>  </span><span style="color:#c678dd;">fn </span><span style="color:#61afef;">area</span><span>(</span><span style="color:#c678dd;">&amp;</span><span style="color:#e06c75;">self</span><span>) -&gt; </span><span style="color:#c678dd;">f64 </span><span>{
</span><span>    </span><span style="color:#e06c75;">self</span><span>.side </span><span style="color:#c678dd;">* </span><span style="color:#e06c75;">self</span><span>.side
</span><span>  }
</span><span>}
</span></code></pre>
<p>Compile-time polymorphism in Rust is also defined using generics like in C++,
but you have to constrain the generic parameter with a trait to access its
methods:</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">fn </span><span style="color:#61afef;">add_area</span><span>&lt;T1, T2&gt;(</span><span style="color:#e06c75;">shape1</span><span>: T1, </span><span style="color:#e06c75;">shape2</span><span>: T2) -&gt; </span><span style="color:#c678dd;">f64
</span><span style="color:#c678dd;">where</span><span> T1: Area, T2: Area {
</span><span>  shape1.</span><span style="color:#61afef;">area</span><span>() </span><span style="color:#c678dd;">+</span><span> shape2.</span><span style="color:#61afef;">area</span><span>()
</span><span>}
</span></code></pre>
<p>What’s cool about Rust is that Trait can be thought of as an abstract class or
interface. So for run-time polymorphism, no extra boilerplate is required.
There’s also no separation between virtual and regular methods, like in C++.
The methods are instead marked to be “dynamically dispatched” using the <code>dyn</code>
keyword.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">fn </span><span style="color:#61afef;">add_area</span><span>(</span><span style="color:#e06c75;">shape1</span><span>: </span><span style="color:#c678dd;">&amp;</span><span>dyn Area, </span><span style="color:#e06c75;">shape2</span><span>: </span><span style="color:#c678dd;">&amp;</span><span>dyn Area) -&gt; </span><span style="color:#c678dd;">f64 </span><span>{
</span><span>  shape1.</span><span style="color:#61afef;">area</span><span>() </span><span style="color:#c678dd;">+</span><span> shape2.</span><span style="color:#61afef;">area</span><span>()
</span><span>}
</span></code></pre>
<p>Similar to the C++ version, <code>&amp;dyn Area</code> just points to an object with the
<code>Area</code> trait, but there are differences between Rust polymorphism and C++
polymorphism, which I won’t go into detail here. To determine the type at
run-time, you actually need to use a “boxed trait”, which is heap-allocated,
also similar to C++.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">let</span><span> shape1: Box&lt;dyn Area&gt; </span><span style="color:#c678dd;">= if </span><span style="color:#61afef;">random_bool</span><span>() {
</span><span>    Box::new(Square { side: </span><span style="color:#e5c07b;">4.0 </span><span>})
</span><span>} </span><span style="color:#c678dd;">else </span><span>{
</span><span>    Box::new(Circle { radius: </span><span style="color:#e5c07b;">2.0 </span><span>})
</span><span>};
</span><span>
</span><span style="color:#c678dd;">let</span><span> shape2: Box&lt;dyn Area&gt; </span><span style="color:#c678dd;">= if </span><span style="color:#61afef;">random_bool</span><span>() {
</span><span>    Box::new(Square { side: </span><span style="color:#e5c07b;">4.0 </span><span>})
</span><span>} </span><span style="color:#c678dd;">else </span><span>{
</span><span>    Box::new(Circle { radius: </span><span style="color:#e5c07b;">2.0 </span><span>})
</span><span>};
</span><span>
</span><span>dbg!(</span><span style="color:#61afef;">add_area</span><span>(shape1.</span><span style="color:#61afef;">as_ref</span><span>(), shape2.</span><span style="color:#61afef;">as_ref</span><span>()))
</span></code></pre>
<p>I really like Rust’s trait; it makes compile-time and run-time polymorphism
feels very similar. Because the methods are guaranteed to exist, you have
better editor completion than in C++. The error messages are also nicer. You
can add traits to existing types, or even primitive ones, so you can have
<code>(69 + 420).is_prime()</code>.</p>
<h2 id="enum-as-tagged-union">Enum as tagged union</h2>
<p>Now for tagged union. In rust they are called <code>enum</code>, and they are much, much
more pleasant to use than their C++ counterpart.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">enum </span><span>Shapes {
</span><span>  Square(</span><span style="color:#c678dd;">f64</span><span>),
</span><span>  Rectangle(</span><span style="color:#c678dd;">f64</span><span>, </span><span style="color:#c678dd;">f64</span><span>),
</span><span>  Circle(</span><span style="color:#c678dd;">f64</span><span>),
</span><span>  Triangle(</span><span style="color:#c678dd;">f64</span><span>, </span><span style="color:#c678dd;">f64</span><span>, </span><span style="color:#c678dd;">f64</span><span>)
</span><span>}
</span></code></pre>
<p>You don’t have as much control over the memory layout as you do in C++, but it
is completely type-safe, as you have to pattern-match the enum to get the
underlying data.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">impl </span><span>Area </span><span style="color:#c678dd;">for </span><span>Shapes {
</span><span>  </span><span style="color:#c678dd;">fn </span><span style="color:#61afef;">area</span><span>(</span><span style="color:#c678dd;">&amp;</span><span style="color:#e06c75;">self</span><span>) -&gt; </span><span style="color:#c678dd;">f64 </span><span>{
</span><span>    </span><span style="color:#c678dd;">match </span><span style="color:#e06c75;">self </span><span>{
</span><span>      Shapes::Square(side) </span><span style="color:#c678dd;">=&gt;</span><span> side </span><span style="color:#c678dd;">*</span><span> side,
</span><span>      Shapes::Rectangle(width, height) </span><span style="color:#c678dd;">=&gt;</span><span> width </span><span style="color:#c678dd;">*</span><span> height,
</span><span>      Shapes::Circle(radius) </span><span style="color:#c678dd;">=&gt;</span><span> radius </span><span style="color:#c678dd;">*</span><span> radius </span><span style="color:#c678dd;">* f64</span><span>::consts::</span><span style="color:#e5c07b;">PI</span><span>,
</span><span>      Shapes::Triangle(side1, side2, side3) </span><span style="color:#c678dd;">=&gt; </span><span>{
</span><span>        </span><span style="color:#c678dd;">let</span><span> s </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">0.5 </span><span style="color:#c678dd;">* </span><span>(side1 </span><span style="color:#c678dd;">+</span><span> side2 </span><span style="color:#c678dd;">+</span><span> side3);
</span><span>        (s </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> side1) </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> side2) </span><span style="color:#c678dd;">* </span><span>(s </span><span style="color:#c678dd;">-</span><span> side3)).</span><span style="color:#61afef;">sqrt</span><span>()
</span><span>      },
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre>
<p>Rust enum is extremely convenient and is the backbone of many features, such as
<code>Option</code> or <code>Result</code>. While I don’t have as much control as in C++, because
enum is a built-in language feature of Rust, constructing and accessing them
feel so much more natural.</p>
<pre data-lang="rust" style="background-color:#282c34;color:#dcdfe4;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#c678dd;">let</span><span> square </span><span style="color:#c678dd;">= </span><span>Shapes::Square(</span><span style="color:#e5c07b;">4.0</span><span>);
</span><span>
</span><span style="color:#c678dd;">if let</span><span> Square(side) </span><span style="color:#c678dd;">=</span><span> square {
</span><span>    dbg!(side);
</span><span>}
</span></code></pre>
<p>Compare this to the C++ version:</p>
<pre data-lang="c++" style="background-color:#282c34;color:#dcdfe4;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#5c6370;">// I can write and use a factory function but still I have to write more code
</span><span>Shape square </span><span style="color:#c678dd;">= </span><span>{
</span><span>  .</span><span style="color:#e06c75;">tag </span><span style="color:#c678dd;">=</span><span> Shape::Types::SQUARE,
</span><span>  .</span><span style="color:#e06c75;">square </span><span style="color:#c678dd;">= </span><span>{
</span><span>    .</span><span style="color:#e06c75;">side </span><span style="color:#c678dd;">= </span><span style="color:#e5c07b;">4
</span><span>  }
</span><span>};
</span><span>
</span><span style="color:#c678dd;">if </span><span>(square.</span><span style="color:#e06c75;">tag </span><span style="color:#c678dd;">==</span><span> Shape::Types::SQUARE) {
</span><span>  std::cout </span><span style="color:#c678dd;">&lt;&lt;</span><span> square.</span><span style="color:#e06c75;">square</span><span>.</span><span style="color:#e06c75;">side </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#98c379;">&#39;</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&#39;</span><span>;
</span><span>
</span><span>  </span><span style="color:#5c6370;">// Nothing prevents me from doing this
</span><span>  std::cout </span><span style="color:#c678dd;">&lt;&lt;</span><span> square.</span><span style="color:#e06c75;">rectangle</span><span>.</span><span style="color:#e06c75;">height </span><span style="color:#c678dd;">&lt;&lt; </span><span style="color:#98c379;">&#39;</span><span style="color:#56b6c2;">\n</span><span style="color:#98c379;">&#39;</span><span>;
</span><span>}
</span></code></pre>
<p>I still prefer this over <code>std::variant</code>, and definitely over using run-time
polymorphism, but I think that Rust enum is superior with its safety and
convenience.</p>
<h1 id="benchmark-and-conclusion">Benchmark and conclusion</h1>
<p>So, let’s finally get into the performance of these two methods. I generated a
one million shapes of those four types, and measured the time it took to
compute the total area for both of the methods.</p>
<table><thead><tr><th>Optimizaion</th><th>Polymorphism</th><th>Tagged union</th></tr></thead><tbody>
<tr><td><code>-O0</code></td><td>25.628 ms</td><td>15.758 ms</td></tr>
<tr><td><code>-O3</code></td><td>6.908 ms</td><td>5.100 ms</td></tr>
</tbody></table>
<p>The tagged union method is 1.6 times faster without optimizations and 1.35
times faster with <code>-O3</code> optimization. As you can see, the individual heap
allocation and virtual method have a noticeable overhead. And this is just 4
different variants and 1 virtual method. The overhead will add up even further.</p>
<p>So, my take is that run-time polymorphism in C++ doesn’t actually prevent you
from manually handling all cases at run-time, isn’t very flexible, you have to
worry about memory safety, and the performance is worse. You can do the same
thing with tagged union—it’s as easy to add more variants, and have higher
performance. Because of this, I can’t see why I should use abstract classes and
virtual methods in C++.</p>

  </article>

      </main>

      <footer class="footer__container">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 352.5 960 188.5" preserveAspectRatio="none" class="footer__split">
  <path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#f7f9fb"/>
  <path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#eff3f7"/>
  <path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill="#e8eef4" stroke="#e8eef4"/>
</svg>

  <div class="footer__bg">
    <div class="footer">
      &copy; 2024 Zap (Huy-Giap Bui).
      Content on this site is licensed under <a href="//creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>.
    </div>

    
  </div>
</footer>

    </div>
  </body>
</html>
