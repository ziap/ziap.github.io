<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          A faster, more flexible alternative to run-time polymorphism in C++ feat. Rust | Zap's website
        
      
    </title><link onload="this.onload=null;this.rel='stylesheet'" as=style href=/styles/fonts.css rel=preload><noscript><link href=/styles/fonts.css rel=stylesheet></noscript><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Zap</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">A faster, more flexible alternative to run-time polymorphism in C++ feat. Rust</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Sun, Feb 11 2024</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="2026 words"> 9 minutes read </abbr></div></div></header><article class=content__body><p>When I first heard about run-time polymorphism in C++ using virtual methods, my first thoughts were like, “This is cool and all, but why would I ever use this?” Then I continued to ignore it because I could always just work around it instead of using it. Until recently, my college lecturer told me that using virtual methods is great for designing and maintaining applications with thousands of objects. I figured that I should write about what run-time polymorphism is, and why I still think that I don’t need it.</p><span id=continue-reading></span><h1 id=a-brief-introduction-to-polymorphism-in-c>A brief introduction to polymorphism in C++</h1><p>Polymorphism means “many-forms”, and in programming, it means designing an API that works with multiple “forms” of input, for example, a function that takes multiple data-type. Consider the following function:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>template</span><span><</span><span style=color:#c678dd>class</span><span> T1, T2>
</span><span style=color:#c678dd>double </span><span style=color:#61afef>add_area</span><span>(T1 </span><span style=color:#e06c75>shape1</span><span>, T2 </span><span style=color:#e06c75>shape2</span><span>) {
</span><span>    </span><span style=color:#c678dd>return</span><span> shape1.</span><span style=color:#e06c75>area</span><span>() </span><span style=color:#c678dd>+</span><span> shape2.</span><span style=color:#e06c75>area</span><span>();
</span><span>}
</span></code></pre><p>This function is polymorphic because it works with any data-type with a member function <code>area</code>. However, the template arguments <code>T1</code> and <code>T2</code> needs to be determined at compile-time, so we only achieved compile-time polymorphism. Run-time polymorphism is a bit complicated:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>class </span><span style=color:#e5c07b>Shape {
</span><span style=color:#c678dd>public</span><span style=color:#e5c07b>:
</span><span style=color:#e5c07b>    </span><span style=color:#61afef>Shape</span><span style=color:#e5c07b>() {}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>virtual double </span><span style=color:#61afef>area</span><span style=color:#e5c07b>() </span><span style=color:#c678dd>const = </span><span style=color:#e5c07b>0;
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>virtual </span><span style=color:#61afef>~Shape</span><span style=color:#e5c07b>() </span><span style=color:#c678dd>= default</span><span style=color:#e5c07b>;
</span><span style=color:#e5c07b>}</span><span>;
</span><span>
</span><span style=color:#c678dd>double </span><span style=color:#61afef>add_area</span><span>(Shape </span><span style=color:#c678dd>*</span><span style=color:#e06c75>shape1</span><span>, Shape </span><span style=color:#c678dd>*</span><span style=color:#e06c75>shape2</span><span>) {
</span><span>    </span><span style=color:#c678dd>return</span><span> shape1-></span><span style=color:#e06c75>area</span><span>() </span><span style=color:#c678dd>+</span><span> shape2-></span><span style=color:#e06c75>area</span><span>();
</span><span>}
</span></code></pre><p>The <code>Shape</code> class is called an “abstract” class, which means that it can’t be allocated and can only serves as an interface for other classes to inherit from. The function <code>add_area</code> takes two pointers that point to two arbitrary objects that inherits from the <code>Shape</code> class. It has to be a pointer because a pointer just points to a region of memory, which could represents any shapes, while a value is statically typed and can only be a single shape. What makes this different from the previous example is that this is an actual function, not a template, and the objects that those pointers point to are determined at run-time, not at compile-time.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span>Square </span><span style=color:#61afef>square</span><span>(</span><span style=color:#e5c07b>4</span><span>);
</span><span>Circle </span><span style=color:#61afef>circle</span><span>(</span><span style=color:#e5c07b>2</span><span>);
</span><span>
</span><span>Shape </span><span style=color:#c678dd>*</span><span>shape1 </span><span style=color:#c678dd>= </span><span style=color:#e06c75>random_bool</span><span>() </span><span style=color:#c678dd>? </span><span>(Shape</span><span style=color:#c678dd>*</span><span>)</span><span style=color:#c678dd>&</span><span>square </span><span style=color:#c678dd>: </span><span>(Shape</span><span style=color:#c678dd>*</span><span>)</span><span style=color:#c678dd>&</span><span>circle;
</span><span>Shape </span><span style=color:#c678dd>*</span><span>shape2 </span><span style=color:#c678dd>= </span><span style=color:#e06c75>random_bool</span><span>() </span><span style=color:#c678dd>? </span><span>(Shape</span><span style=color:#c678dd>*</span><span>)</span><span style=color:#c678dd>&</span><span>square </span><span style=color:#c678dd>: </span><span>(Shape</span><span style=color:#c678dd>*</span><span>)</span><span style=color:#c678dd>&</span><span>circle;
</span><span>
</span><span>std::cout </span><span style=color:#c678dd><< </span><span style=color:#e06c75>add_area</span><span>(shape1, shape2) </span><span style=color:#c678dd><< </span><span style=color:#98c379>'</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>'</span><span>;
</span></code></pre><h1 id=a-simple-example>A simple example</h1><p>Run-time polymorphism is often used when the data-type is not known at compile time. Maybe the users want to select what type of shape to add the area together. Let’s extend the previous example to include run-time data. You have to import the shapes from a file. For demonstration purposes, the file format is extremely simple. It’s a text file with every line containing a string representing the shape type, and floating point numbers representing the shape attributes. The shape types, their attributes and how to compute the area are described in the table below:<table><thead><tr><th>shape type<th>attributes<th>area formula<tbody><tr><td>“square”<td>side<td>side * side<tr><td>“rectangle”<td>width, height<td>width * height<tr><td>“circle”<td>radius<td>radius * radius * PI<tr><td>“triangle”<td>3 sides<td>Heron’s formula<sup class=footnote-reference><a href=#1>1</a></sup></table><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p><a href="https://en.wikipedia.org/wiki/Heron's_formula">https://en.wikipedia.org/wiki/Heron's_formula</a></div><p>We can’t tell what shape they are until we have read the file at run-time. So to get the total area of the entire file, we need a run-time polymorphic function:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>double </span><span style=color:#61afef>total_area</span><span>(Shape </span><span style=color:#c678dd>**</span><span style=color:#e06c75>shapes</span><span>, size_t </span><span style=color:#e06c75>shapes_len</span><span>) {
</span><span>    </span><span style=color:#c678dd>double</span><span> result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>for </span><span>(size_t i </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>; i </span><span style=color:#c678dd><</span><span> shapes_len; </span><span style=color:#c678dd>++</span><span>i) {
</span><span>        result </span><span style=color:#c678dd>+=</span><span> shapes[i]-></span><span style=color:#e06c75>area</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>The <code>Shape</code> class is the same as the above, but notice that we need to have double pointer indirection. Unlike the example above, the shapes don’t actually exist until we read the file at run-time. Because the memory layout for every shape is different and unknown, we can’t just store them in a contiguous region of memory. Which means that every element of the shapes array must be heap-allocated individually. That is pretty expensive, and you can mess up if you’re not careful. So instead of using raw pointers, in the spirit of C++, here is a safer and potentially faster version of the previous function:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>double </span><span style=color:#61afef>total_area</span><span>(std::span&LTstd::unique_ptr&LTShape>> </span><span style=color:#e06c75>shapes</span><span>) {
</span><span>    </span><span style=color:#c678dd>double</span><span> result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>for </span><span>(std::unique_ptr&LTShape> </span><span style=color:#c678dd>&</span><span>shape </span><span style=color:#c678dd>:</span><span> shapes) {
</span><span>        result </span><span style=color:#c678dd>+=</span><span> shape-></span><span style=color:#e06c75>area</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>It’s arguably uglier, but the <code>std::unique_ptr</code> saves us from the hassle of cleaning up memory, and since we’re using smart pointers anyways, I’m throwing in <code>std::span</code>—a new C++20 feature—as well so we don’t have to pass in the length, we can use the range-based for loop for iteration, and the function automatically works with <code>std::vector</code>s.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span>std::vector&LTstd::unique_ptr&LTShape>> shapes;
</span><span>
</span><span>shapes.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTSquare>(</span><span style=color:#e5c07b>4</span><span>));
</span><span>shapes.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTCircle>(</span><span style=color:#e5c07b>2</span><span>));
</span><span>shapes.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTRectangle>(</span><span style=color:#e5c07b>3</span><span>, </span><span style=color:#e5c07b>4</span><span>));
</span><span>shapes.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTTriangle>(</span><span style=color:#e5c07b>3</span><span>, </span><span style=color:#e5c07b>4</span><span>, </span><span style=color:#e5c07b>5</span><span>));
</span><span>
</span><span>std::cout </span><span style=color:#c678dd><< </span><span style=color:#e06c75>total_area</span><span>(shapes) </span><span style=color:#c678dd><< </span><span style=color:#98c379>'</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>'</span><span>; </span><span style=color:#5c6370>// 46.566370614359172
</span></code></pre><p>This is great! It automatically figures out how to compute the area for every shape that we throw at it. We don’t need to manually handle every single case, and even though the shapes are heap allocated, <code>std::unique_ptr</code> makes working with them less painful. Also, notice how I didn’t show a single line of code on how to compute the area, because with polymorphism, it actually doesn’t matter. But currently we are still hard-coding the shapes, so this is still possible even with compile-time polymorphism. Let’s justify this by importing the shapes from the file.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>enum class </span><span>ShapeTypes {
</span><span>    SQUARE,
</span><span>    RECTANGLE,
</span><span>    CIRCLE,
</span><span>    TRIANGLE
</span><span>};
</span><span>
</span><span style=color:#c678dd>static const</span><span> std::unordered_map&LTstd::string_view, ShapeTypes> shape_map </span><span style=color:#c678dd>= </span><span>{
</span><span>    {</span><span style=color:#98c379>"square"</span><span>, ShapeTypes::SQUARE},
</span><span>    {</span><span style=color:#98c379>"rectangle"</span><span>, ShapeTypes::RECTANGLE},
</span><span>    {</span><span style=color:#98c379>"circle"</span><span>, ShapeTypes::CIRCLE},
</span><span>    {</span><span style=color:#98c379>"triangle"</span><span>, ShapeTypes::TRIANGLE}
</span><span>};
</span><span>
</span><span>std::vector&LTstd::unique_ptr&LTShape>> </span><span style=color:#61afef>get_shapes</span><span>(</span><span style=color:#c678dd>const char *</span><span style=color:#e06c75>file_path</span><span>) {
</span><span>    std::vector&LTstd::unique_ptr&LTShape>> result;
</span><span>    std::ifstream </span><span style=color:#e06c75>fin</span><span>(file_path);
</span><span>
</span><span>    std::string type_str;
</span><span>
</span><span>    </span><span style=color:#c678dd>while </span><span>(fin </span><span style=color:#c678dd>>></span><span> type_str) {
</span><span>        </span><span style=color:#c678dd>switch </span><span>(shape_map.</span><span style=color:#e06c75>find</span><span>(type_str)-></span><span style=color:#e06c75>second</span><span>) {
</span><span>            </span><span style=color:#c678dd>case</span><span> ShapeTypes::SQUARE: {
</span><span>                </span><span style=color:#c678dd>double</span><span> side;
</span><span>                fin </span><span style=color:#c678dd>>></span><span> side;
</span><span>                result.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTSquare>(side));
</span><span>                </span><span style=color:#c678dd>break</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#c678dd>case</span><span> ShapeTypes::RECTANGLE: {
</span><span>                </span><span style=color:#c678dd>double</span><span> width, height;
</span><span>                fin </span><span style=color:#c678dd>>></span><span> width </span><span style=color:#c678dd>>></span><span> height;
</span><span>                result.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTRectangle>(width, height));
</span><span>                </span><span style=color:#c678dd>break</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#c678dd>case</span><span> ShapeTypes::CIRCLE: {
</span><span>                </span><span style=color:#c678dd>double</span><span> radius;
</span><span>                fin </span><span style=color:#c678dd>>></span><span> radius;
</span><span>                result.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTCircle>(radius));
</span><span>                </span><span style=color:#c678dd>break</span><span>;
</span><span>            }
</span><span>            </span><span style=color:#c678dd>case</span><span> ShapeTypes::TRIANGLE: {
</span><span>                </span><span style=color:#c678dd>double</span><span> side1, side2, side3;
</span><span>                fin </span><span style=color:#c678dd>>></span><span> side1 </span><span style=color:#c678dd>>></span><span> side2 </span><span style=color:#c678dd>>></span><span> side3;
</span><span>                result.</span><span style=color:#e06c75>push_back</span><span>(std::</span><span style=color:#e06c75>make_unique</span><span>&LTTriangle>(side1, side2, side3));
</span><span>                </span><span style=color:#c678dd>break</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>Okay, now it’s no longer pretty. We tried so hard not to write the code that handles different shape types, but now, when reading the file, we can’t avoid it anymore. But if we don’t import the shape from the files dynamically at run-time, then it’s the same as compile-time polymorphism. Also, if we want to tweak the function, like, for example: “Get the total area of all circles and triangles”, we need to update the abstract class to expose more information:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>class </span><span style=color:#e5c07b>Shape {
</span><span style=color:#c678dd>public</span><span style=color:#e5c07b>:
</span><span style=color:#e5c07b>    </span><span style=color:#61afef>Shape</span><span style=color:#e5c07b>() {}
</span><span style=color:#e5c07b>
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>virtual double </span><span style=color:#61afef>area</span><span style=color:#e5c07b>() </span><span style=color:#c678dd>const = </span><span style=color:#e5c07b>0;
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>virtual double </span><span style=color:#61afef>is_circle_or_triangle</span><span style=color:#e5c07b>() </span><span style=color:#c678dd>const = </span><span style=color:#e5c07b>0;
</span><span style=color:#e5c07b>    </span><span style=color:#c678dd>virtual </span><span style=color:#61afef>~Shape</span><span style=color:#e5c07b>() </span><span style=color:#c678dd>= default</span><span style=color:#e5c07b>;
</span><span style=color:#e5c07b>}</span><span>;
</span><span>
</span><span style=color:#c678dd>double </span><span style=color:#61afef>total_area_circles_and_triangles</span><span>(std::span&LTstd::unique_ptr&LTShape>> </span><span style=color:#e06c75>shapes</span><span>) {
</span><span>    </span><span style=color:#c678dd>double</span><span> result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>for </span><span>(std::unique_ptr&LTShape> </span><span style=color:#c678dd>&</span><span>shape </span><span style=color:#c678dd>:</span><span> shapes) {
</span><span>        </span><span style=color:#c678dd>if </span><span>(shape-></span><span style=color:#e06c75>is_circle_or_triangle</span><span>()) {
</span><span>            result </span><span style=color:#c678dd>+=</span><span> shape-></span><span style=color:#e06c75>area</span><span>();
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>Then we need to manually implement the new method for all shapes. So while run-time polymorphism sounds great on paper, it falls apart when you actually write the entire system that operates at run-time. What really changed is that run-time polymorphism hides away the difficulty of maintaining multiple types of data in some places. It might be useful in certain circumstances, but the difficulty is still there.<h1 id=the-alternative>The alternative</h1><p>So, how do we store multiple shapes in the same array without run-time polymorphism? The answer is to use a data structure known as a tagged union. Instead of creating a function that accepts multiple types, one for each shape, we create a type that represents all the shapes, and just pass it to a regular function. To create a tagged union, there’s <code>std::variant</code> in C++, but I think that it’s more convenient to just literally use a tag and a union. In fact, this structure is so simple that you don’t even need any of C++’s features and just write it in plain C. The only C++ feature I use right now (other than member functions) is <code>enum class</code> only because it is scoped and because I’m in C++ anyways.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>struct </span><span>Shape {
</span><span>    </span><span style=color:#c678dd>enum class </span><span>Types {
</span><span>        SQUARE,
</span><span>        RECTANGLE,
</span><span>        CIRCLE,
</span><span>        TRIANGLE
</span><span>    };
</span><span>
</span><span>    Types tag;
</span><span>
</span><span>    </span><span style=color:#c678dd>union </span><span>{
</span><span>        </span><span style=color:#c678dd>struct </span><span>{
</span><span>            </span><span style=color:#c678dd>double</span><span> side;
</span><span>        } square;
</span><span>
</span><span>        </span><span style=color:#c678dd>struct </span><span>{
</span><span>            </span><span style=color:#c678dd>double</span><span> width, height;
</span><span>        } rectangle;
</span><span>
</span><span>        </span><span style=color:#c678dd>struct </span><span>{
</span><span>            </span><span style=color:#c678dd>double</span><span> radius;
</span><span>        } circle;
</span><span>
</span><span>        </span><span style=color:#c678dd>struct </span><span>{
</span><span>            </span><span style=color:#c678dd>double</span><span> sides[</span><span style=color:#e5c07b>3</span><span>];
</span><span>        } triangle;
</span><span>
</span><span>        </span><span style=color:#c678dd>double</span><span> attrs[</span><span style=color:#e5c07b>0</span><span>];
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#c678dd>double </span><span style=color:#61afef>area</span><span>() </span><span style=color:#c678dd>const </span><span>{
</span><span>        </span><span style=color:#c678dd>switch </span><span>(tag) {
</span><span>            </span><span style=color:#c678dd>case</span><span> Types::SQUARE: </span><span style=color:#c678dd>return</span><span> square.</span><span style=color:#e06c75>side </span><span style=color:#c678dd>*</span><span> square.</span><span style=color:#e06c75>side</span><span>;
</span><span>            </span><span style=color:#c678dd>case</span><span> Types::RECTANGLE: </span><span style=color:#c678dd>return</span><span> rectangle.</span><span style=color:#e06c75>width </span><span style=color:#c678dd>*</span><span> rectangle.</span><span style=color:#e06c75>height</span><span>;
</span><span>            </span><span style=color:#c678dd>case</span><span> Types::CIRCLE: </span><span style=color:#c678dd>return</span><span> circle.</span><span style=color:#e06c75>radius </span><span style=color:#c678dd>*</span><span> circle.</span><span style=color:#e06c75>radius </span><span style=color:#c678dd>*</span><span> M_PI;
</span><span>            </span><span style=color:#c678dd>case</span><span> Types::TRIANGLE: {
</span><span>                </span><span style=color:#c678dd>const double *</span><span>sides </span><span style=color:#c678dd>=</span><span> triangle.</span><span style=color:#e06c75>sides</span><span>;
</span><span>                </span><span style=color:#c678dd>const double</span><span> s </span><span style=color:#c678dd>= </span><span>(sides[</span><span style=color:#e5c07b>0</span><span>] </span><span style=color:#c678dd>+</span><span> sides[</span><span style=color:#e5c07b>1</span><span>] </span><span style=color:#c678dd>+</span><span> sides[</span><span style=color:#e5c07b>2</span><span>]) </span><span style=color:#c678dd>* </span><span style=color:#e5c07b>0.5</span><span>;
</span><span>
</span><span>                </span><span style=color:#c678dd>return </span><span style=color:#61afef>sqrt</span><span>(s </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> sides[</span><span style=color:#e5c07b>0</span><span>]) </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> sides[</span><span style=color:#e5c07b>1</span><span>]) </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> sides[</span><span style=color:#e5c07b>2</span><span>]));
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#e06c75>__builtin_unreachable</span><span>();
</span><span>    }
</span><span>};
</span></code></pre><p>Before, we did’t have to care about how the shapes were implemented but now we do because it’s no longer hidden behind abstract classes and virtual methods. Remember, they’re hidden and abstracted away, but they’re still there. I think that the code that computes the area in every derived class is the same as the same code, but in the switch cases. It feels like we have to manually handle different shapes in the <code>area</code> method. But as we saw before, manually handling different cases is inevitable at run-time, so I don’t think there’s a good reason to avoid it. You might wonder: “What happens when you add a new shape?”. Well, just add a new shape to the enum and the compiler will emit a warning that you haven’t handled all enum values. Constructing a shape is also simple with designated initializers.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span>Shape square </span><span style=color:#c678dd>= </span><span>{
</span><span>    .</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>=</span><span> Shape::Types::SQUARE,
</span><span>    .</span><span style=color:#e06c75>square </span><span style=color:#c678dd>= </span><span>{
</span><span>        .</span><span style=color:#e06c75>side </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>4
</span><span>    }
</span><span>};
</span><span>
</span><span>Shape triangle </span><span style=color:#c678dd>= </span><span>{
</span><span>    .</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>=</span><span> Shape::Types::TRIANGLE,
</span><span>    .</span><span style=color:#e06c75>triangle </span><span style=color:#c678dd>= </span><span>{
</span><span>        .</span><span style=color:#e06c75>sides </span><span style=color:#c678dd>= </span><span>{</span><span style=color:#e5c07b>3</span><span>, </span><span style=color:#e5c07b>4</span><span>, </span><span style=color:#e5c07b>5</span><span>}
</span><span>    }
</span><span>};
</span></code></pre><p>You can even use factory methods to simplify the creation of shapes, but I think that designated initializers are good enough. One of the downsides of this approach is reduced type safety. There’s nothing preventing you from accessing the radius of a square. If you know your union, then it’s fine. But mistakes can happen, and this is one place where you can mess up. Now <code>Shape</code> is an actual class, with a well-defined, static memory layout. So its instances <em>are</em> shapes, and not pointers pointing to the actual shape. This effectively removes one level of indirection, and all shapes can be stored in the same contiguous memory region.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>double </span><span style=color:#61afef>total_area</span><span>(std::span&LTShape> </span><span style=color:#e06c75>shapes</span><span>) {
</span><span>    </span><span style=color:#c678dd>double</span><span> result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>for </span><span>(Shape </span><span style=color:#c678dd>&</span><span>shape </span><span style=color:#c678dd>:</span><span> shapes) {
</span><span>        result </span><span style=color:#c678dd>+=</span><span> shape.</span><span style=color:#e06c75>area</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>Now we don’t have to worry about cleaning up individual shape, or even have to use <code>std::unique_ptr</code>, and it might even help with performance! But before that, let’s see how do we import the shapes from the file.<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>static const</span><span> std::unordered_map&LTstd::string_view, Shape::Types> shape_map </span><span style=color:#c678dd>= </span><span>{
</span><span>    {</span><span style=color:#98c379>"square"</span><span>, Shape::Types::SQUARE},
</span><span>    {</span><span style=color:#98c379>"rectangle"</span><span>, Shape::Types::RECTANGLE},
</span><span>    {</span><span style=color:#98c379>"circle"</span><span>, Shape::Types::CIRCLE},
</span><span>    {</span><span style=color:#98c379>"triangle"</span><span>, Shape::Types::TRIANGLE}
</span><span>};
</span><span>
</span><span>std::vector&LTShape> </span><span style=color:#61afef>get_shapes</span><span>(</span><span style=color:#c678dd>const char *</span><span style=color:#e06c75>file_path</span><span>) {
</span><span>    std::vector&LTShape> result;
</span><span>    std::ifstream </span><span style=color:#e06c75>fin</span><span>(file_path);
</span><span>
</span><span>    std::string line;
</span><span>
</span><span>    </span><span style=color:#c678dd>while </span><span>(std::</span><span style=color:#e06c75>getline</span><span>(fin, line)) {
</span><span>        std::stringstream </span><span style=color:#e06c75>ss</span><span>(line);
</span><span>        std::string type_str;
</span><span>        ss </span><span style=color:#c678dd>>></span><span> type_str;
</span><span>
</span><span>        Shape shape;
</span><span>        shape.</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>=</span><span> shape_map.</span><span style=color:#e06c75>find</span><span>(type_str)-></span><span style=color:#e06c75>second</span><span>;
</span><span>
</span><span>        size_t attrs_len </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>        </span><span style=color:#c678dd>double</span><span> attr;
</span><span>        </span><span style=color:#c678dd>while </span><span>(ss </span><span style=color:#c678dd>>></span><span> attr) shape.</span><span style=color:#e06c75>attrs</span><span>[attrs_len</span><span style=color:#c678dd>++</span><span>] </span><span style=color:#c678dd>=</span><span> attr;
</span><span>
</span><span>        result.</span><span style=color:#e06c75>push_back</span><span>(shape);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>This, in my opinion, is even nicer than the previous implementation. We already have the <code>Shape::Types</code> enum for the tag, so we can easily reuse it here. Remember <code>double attrs[0]</code>? It’s an array representing the underlying values of the shape attributes. Because the file is already in the correct order, we can just push items into that array instead of matching the shape type and constructing the correct shape. So by having more control over the memory layout, we can analyze and reduce some repetition. What about the example of only adding the area of circles and triangles? It’s just a single if statement:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#c678dd>double </span><span style=color:#61afef>total_area_circles_and_triangles</span><span>(std::span&LTShape> </span><span style=color:#e06c75>shapes</span><span>) {
</span><span>    </span><span style=color:#c678dd>double</span><span> result </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#c678dd>for </span><span>(Shape </span><span style=color:#c678dd>&</span><span>shape </span><span style=color:#c678dd>:</span><span> shapes) {
</span><span>        </span><span style=color:#c678dd>if </span><span>(shape.</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>==</span><span> Shape::Types::CIRCLE </span><span style=color:#c678dd>||</span><span> shape.</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>==</span><span> Shape::Types::TRIANGLE) {
</span><span>            result </span><span style=color:#c678dd>+=</span><span> shape.</span><span style=color:#e06c75>area</span><span>();
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#c678dd>return</span><span> result;
</span><span>}
</span></code></pre><p>You don’t need to edit all the shapes just to add that. So by not avoiding handling different shapes manually, we increased the flexibility of our code, and sometimes adding features is easier because of it.<h1 id=bonus-content-polymorphism-and-tagged-union-in-rust>Bonus content: Polymorphism and Tagged union in Rust</h1><p>If you are not interested, feel free to skip to the <a href=https://ziap.github.io/blog/polymorphism/#benchmark-and-conclusion>benchmark</a>.<h2 id=polymorphism-using-trait>Polymorphism using Trait</h2><p>So that’s about C++, but what about polymorphism in another statically typed language? In Rust, methods and other shared behaviors are defined using Trait instead of inheritance. For example, instead of <code>Square</code> and <code>Circle</code> inheriting <code>Shape</code>, they instead have the trait <code>Area</code>.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>trait </span><span>Area {
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>area</span><span>(</span><span style=color:#c678dd>&</span><span style=color:#e06c75>self</span><span>) -> </span><span style=color:#c678dd>f64</span><span>;
</span><span>}
</span><span>
</span><span style=color:#c678dd>struct </span><span>Square {
</span><span>    </span><span style=color:#e06c75>side</span><span>: </span><span style=color:#c678dd>f64
</span><span>}
</span><span>
</span><span style=color:#c678dd>impl </span><span>Area </span><span style=color:#c678dd>for </span><span>Square {
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>area</span><span>(</span><span style=color:#c678dd>&</span><span style=color:#e06c75>self</span><span>) -> </span><span style=color:#c678dd>f64 </span><span>{
</span><span>        </span><span style=color:#e06c75>self</span><span>.side </span><span style=color:#c678dd>* </span><span style=color:#e06c75>self</span><span>.side
</span><span>    }
</span><span>}
</span></code></pre><p>Compile-time polymorphism in Rust is also defined using generics like in C++, but you have to constrain the generic parameter with a trait to access its methods:<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>fn </span><span style=color:#61afef>add_area</span><span>&LTT1, T2>(</span><span style=color:#e06c75>shape1</span><span>: T1, </span><span style=color:#e06c75>shape2</span><span>: T2) -> </span><span style=color:#c678dd>f64
</span><span style=color:#c678dd>where</span><span> T1: Area, T2: Area {
</span><span>    shape1.</span><span style=color:#61afef>area</span><span>() </span><span style=color:#c678dd>+</span><span> shape2.</span><span style=color:#61afef>area</span><span>()
</span><span>}
</span></code></pre><p>What’s cool about Rust is that Trait can be thought of as an abstract class or interface. So for run-time polymorphism, no extra boilerplate is required. There’s also no separation between virtual and regular methods, like in C++. The methods are instead marked to be “dynamically dispatched” using the <code>dyn</code> keyword.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>fn </span><span style=color:#61afef>add_area</span><span>(</span><span style=color:#e06c75>shape1</span><span>: </span><span style=color:#c678dd>&</span><span>dyn Area, </span><span style=color:#e06c75>shape2</span><span>: </span><span style=color:#c678dd>&</span><span>dyn Area) -> </span><span style=color:#c678dd>f64 </span><span>{
</span><span>    shape1.</span><span style=color:#61afef>area</span><span>() </span><span style=color:#c678dd>+</span><span> shape2.</span><span style=color:#61afef>area</span><span>()
</span><span>}
</span></code></pre><p>Similar to the C++ version, <code>&dyn Area</code> just points to an object with the <code>Area</code> trait, but there are differences between Rust polymorphism and C++ polymorphism, which I won’t go into detail here. To determine the type at run-time, you actually need to use a “boxed trait”, which is heap-allocated, also similar to C++.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>let</span><span> shape1: Box&LTdyn Area> </span><span style=color:#c678dd>= if </span><span style=color:#61afef>random_bool</span><span>() {
</span><span>    Box::new(Square { side: </span><span style=color:#e5c07b>4.0 </span><span>})
</span><span>} </span><span style=color:#c678dd>else </span><span>{
</span><span>    Box::new(Circle { radius: </span><span style=color:#e5c07b>2.0 </span><span>})
</span><span>};
</span><span>
</span><span style=color:#c678dd>let</span><span> shape2: Box&LTdyn Area> </span><span style=color:#c678dd>= if </span><span style=color:#61afef>random_bool</span><span>() {
</span><span>    Box::new(Square { side: </span><span style=color:#e5c07b>4.0 </span><span>})
</span><span>} </span><span style=color:#c678dd>else </span><span>{
</span><span>    Box::new(Circle { radius: </span><span style=color:#e5c07b>2.0 </span><span>})
</span><span>};
</span><span>
</span><span>dbg!(</span><span style=color:#61afef>add_area</span><span>(shape1.</span><span style=color:#61afef>as_ref</span><span>(), shape2.</span><span style=color:#61afef>as_ref</span><span>()))
</span></code></pre><p>I really like Rust’s trait; it makes compile-time and run-time polymorphism feels very similar. Because the methods are guaranteed to exist, you have better editor completion than in C++. The error messages are also nicer. You can add traits to existing types, or even primitive ones, so you can have <code>(69 + 420).is_prime()</code>.<h2 id=enum-as-tagged-union>Enum as tagged union</h2><p>Now for tagged union. In rust they are called <code>enum</code>, and they are much, much more pleasant to use than their C++ counterpart.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>enum </span><span>Shapes {
</span><span>    Square(</span><span style=color:#c678dd>f64</span><span>),
</span><span>    Rectangle(</span><span style=color:#c678dd>f64</span><span>, </span><span style=color:#c678dd>f64</span><span>),
</span><span>    Circle(</span><span style=color:#c678dd>f64</span><span>),
</span><span>    Triangle(</span><span style=color:#c678dd>f64</span><span>, </span><span style=color:#c678dd>f64</span><span>, </span><span style=color:#c678dd>f64</span><span>)
</span><span>}
</span></code></pre><p>You don’t have as much control over the memory layout as you do in C++, but it is completely type-safe, as you have to pattern-match the enum to get the underlying data.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>impl </span><span>Area </span><span style=color:#c678dd>for </span><span>Shapes {
</span><span>    </span><span style=color:#c678dd>fn </span><span style=color:#61afef>area</span><span>(</span><span style=color:#c678dd>&</span><span style=color:#e06c75>self</span><span>) -> </span><span style=color:#c678dd>f64 </span><span>{
</span><span>        </span><span style=color:#c678dd>match </span><span style=color:#e06c75>self </span><span>{
</span><span>            Shapes::Square(side) </span><span style=color:#c678dd>=></span><span> side </span><span style=color:#c678dd>*</span><span> side,
</span><span>            Shapes::Rectangle(width, height) </span><span style=color:#c678dd>=></span><span> width </span><span style=color:#c678dd>*</span><span> height,
</span><span>            Shapes::Circle(radius) </span><span style=color:#c678dd>=></span><span> radius </span><span style=color:#c678dd>*</span><span> radius </span><span style=color:#c678dd>* f64</span><span>::consts::</span><span style=color:#e5c07b>PI</span><span>,
</span><span>            Shapes::Triangle(side1, side2, side3) </span><span style=color:#c678dd>=> </span><span>{
</span><span>                </span><span style=color:#c678dd>let</span><span> s </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>0.5 </span><span style=color:#c678dd>* </span><span>(side1 </span><span style=color:#c678dd>+</span><span> side2 </span><span style=color:#c678dd>+</span><span> side3);
</span><span>                (s </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> side1) </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> side2) </span><span style=color:#c678dd>* </span><span>(s </span><span style=color:#c678dd>-</span><span> side3)).</span><span style=color:#61afef>sqrt</span><span>()
</span><span>            },
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>Rust enum is extremely convenient and is the backbone of many features, such as <code>Option</code> or <code>Result</code>. While I don’t have as much control as in C++, because enum is a built-in language feature of Rust, constructing and accessing them feel so much more natural.<pre class=language-rust data-lang=rust style=color:#dcdfe4;background-color:#282c34><code class=language-rust data-lang=rust><span style=color:#c678dd>let</span><span> square </span><span style=color:#c678dd>= </span><span>Shapes::Square(</span><span style=color:#e5c07b>4.0</span><span>);
</span><span>
</span><span style=color:#c678dd>if let</span><span> Square(side) </span><span style=color:#c678dd>=</span><span> square {
</span><span>    dbg!(side);
</span><span>}
</span></code></pre><p>Compare this to the C++ version:<pre class=language-c++ data-lang=c++ style=color:#dcdfe4;background-color:#282c34><code class=language-c++ data-lang=c++><span style=color:#5c6370>// I can write and use a factory function but still I have to write more code
</span><span>Shape square </span><span style=color:#c678dd>= </span><span>{
</span><span>    .</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>=</span><span> Shape::Types::SQUARE,
</span><span>    .</span><span style=color:#e06c75>square </span><span style=color:#c678dd>= </span><span>{
</span><span>        .</span><span style=color:#e06c75>side </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>4
</span><span>    }
</span><span>};
</span><span>
</span><span style=color:#c678dd>if </span><span>(square.</span><span style=color:#e06c75>tag </span><span style=color:#c678dd>==</span><span> Shape::Types::SQUARE) {
</span><span>    std::cout </span><span style=color:#c678dd><<</span><span> square.</span><span style=color:#e06c75>square</span><span>.</span><span style=color:#e06c75>side </span><span style=color:#c678dd><< </span><span style=color:#98c379>'</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>'</span><span>;
</span><span>
</span><span>    </span><span style=color:#5c6370>// Nothing prevents me from doing this
</span><span>    std::cout </span><span style=color:#c678dd><<</span><span> square.</span><span style=color:#e06c75>rectangle</span><span>.</span><span style=color:#e06c75>height </span><span style=color:#c678dd><< </span><span style=color:#98c379>'</span><span style=color:#56b6c2>\n</span><span style=color:#98c379>'</span><span>;
</span><span>}
</span></code></pre><p>I still prefer this over <code>std::variant</code>, and definitely over using run-time polymorphism, but I think that Rust enum is superior with its safety and convenience.<h1 id=benchmark-and-conclusion>Benchmark and conclusion</h1><p>So, let’s finally get into the performance of these two methods. I generated a one million shapes of those four types, and measured the time it took to compute the total area for both of the methods.<table><thead><tr><th>Optimization<th>Polymorphism<th>Tagged union<tbody><tr><td><code>-O0</code><td>25.628 ms<td>15.758 ms<tr><td><code>-O3</code><td>6.908 ms<td>5.100 ms</table><p>The tagged union method is 1.6 times faster without optimizations and 1.35 times faster with <code>-O3</code> optimization. As you can see, the individual heap allocation and virtual method have a noticeable overhead. And this is just 4 different variants and 1 virtual method. The overhead will add up even further.<p>So, my take is that run-time polymorphism in C++ doesn’t actually prevent you from manually handling all cases at run-time, isn’t very flexible, you have to worry about memory safety, and the performance is worse. You can do the same thing with tagged union—it’s as easy to add more variants, and have higher performance. Because of this, I can’t see why I should use abstract classes and virtual methods in C++.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Zap (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>