<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="Bui Huy Giap's personal website and blog" name=description><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><title>
      
        
          Setting up a reproducible cross-compiling environment in NixOS | Zap's website
        
      
    </title><link href=/styles/fonts-critical.css rel=stylesheet><link onload="this.media='all'" href=/styles/fonts.css media=none rel=stylesheet><noscript><link href=/styles/fonts.css rel=stylesheet></noscript><style>h1{font-size:1.682rem}h2{font-size:1.414rem}h3{font-size:1.189rem}h4{font-size:1rem}h5{font-size:.841rem}h6{font-size:.707rem}</style><link href=/styles/base.css rel=stylesheet><link href=/styles/nav.css rel=stylesheet><link href=/styles/footer.css rel=stylesheet><link href=/rss.xml rel=alternate title=RSS type=application/rss+xml><link href=/styles/page.css rel=stylesheet><body class=font-loaded><div class=nav__bg><div class=nav__container><nav class=nav><h3 class=nav__title><a class=nav__title__link href=/>Zap</a></h3><ul class=nav__links><li><a class=nav__link href=/works>Works</a><li><a class=nav__link href=/blog>Blog</a><li><a class=nav__link href=/about>About</a></ul></nav></div></div><div class=container><main class=content><header class=post-header><h1 class="post-header__title title">Setting up a reproducible cross-compiling environment in NixOS</h1><div class=post-header__meta><div class=post-header__data><svg viewbox="0 0 448 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M128 0c17.7 0 32 14.3 32 32V64H288V32c0-17.7 14.3-32 32-32s32 14.3 32 32V64h48c26.5 0 48 21.5 48 48v48H0V112C0 85.5 21.5 64 48 64H96V32c0-17.7 14.3-32 32-32zM0 192H448V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V192zm64 80v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm128 0v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H208c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V272c0-8.8-7.2-16-16-16H336zM64 400v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H80c-8.8 0-16 7.2-16 16zm144-16c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H208zm112 16v32c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V400c0-8.8-7.2-16-16-16H336c-8.8 0-16 7.2-16 16z"/></svg> Tue, Jan 21 2025</div><div class=post-header__data><svg viewbox="0 0 512 512" height=1em xmlns=http://www.w3.org/2000/svg><path d="M256 0a256 256 0 1 1 0 512A256 256 0 1 1 256 0zM232 120V256c0 8 4 15.5 10.7 20l96 64c11 7.4 25.9 4.4 33.3-6.7s4.4-25.9-6.7-33.3L280 243.2V120c0-13.3-10.7-24-24-24s-24 10.7-24 24z"/></svg><abbr title="1803 words"> 8 minutes read </abbr></div></div></header><article class=content__body><p>NixOS makes it very hard to run dynamically linked application, to the point where packaging is the path of least resistance. I don’t consider this a problem of NixOS, but rather a problem of dynamic linking. This is why when I distribute a compiled application to a NixOS system, I usually do one of the following:<ul><li>Create a statically linked Linux executable and use it directly.<li>Cross-compile the application to Windows and run the .exe file with Wine.</ul><p>To do either of these, a cross-compiling NixOS environment is required, so this article documents my process of setting that up for Rust, Zig, C, and C++.</p><span id=continue-reading></span><h1 id=why-do-you-need-cross-compilation-for-static-linking>Why do you need cross-compilation for static linking</h1><p>The statement sound absurd, but this has been the state of Linux development forever, more particularly development on <strong>GNU</strong>/Linux systems that uses the GNU standard C library, or Glibc. Glibc is designed with dynamic linking in mind for performance and sharing between multiple programs. Other than not working on NixOS, dynamic linking also causes ABI incompatibilities and <a href=//en.wikipedia.org/wiki/DLL_hell>DLL hells</a>. This is why nowadays people bundle applications with their dynamically linked dependencies together in package formats such as Flatpak, AppImage, or the Nix package format.<p>To statically link your application, you can either skip the libc layer and directly invoke system calls, or you can use a different implementation of libc that allows static linking. Linking against a different standard C library is considered a different compilation target, so it requires a different toolchain and a cross-compilation approach. A popular Glibc alternative is Musl, which allows efficient static linking. This is what I often use to produce statically linked Linux binaries.<h1 id=rust>Rust</h1><p>Let’s start with Rust, I wrote and cross-compiled <a href=//github.com/ziap/ninja>a web server</a> a while ago on a “normal” Linux distribution (Fedora), so I have a rough idea on how to perform cross-compilation with Rust:<ul><li>Install the system packages required for cross-compiling to your target<li>Add the target with <code>rustup target add</code><li>Compile with the <code>--target</code> argument</ul><p>But before doing any cross-compilation, let’s set up a baseline Rust project.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span>{
</span><span>  </span><span style=color:#e5c07b>description </span><span style=color:#c678dd>= </span><span style=color:#98c379>"A basic Rust flake"</span><span>;
</span><span>
</span><span>  </span><span style=color:#e5c07b>inputs </span><span style=color:#c678dd>= </span><span>{
</span><span>    </span><span style=color:#e5c07b>nixpkgs</span><span>.</span><span style=color:#e5c07b>url </span><span style=color:#c678dd>= </span><span style=color:#98c379>"nixpkgs/nixos-unstable"</span><span>;
</span><span>  };
</span><span>
</span><span>  </span><span style=color:#e5c07b>outputs </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{ </span><span>self</span><span style=color:#c678dd>, </span><span>nixpkgs </span><span style=color:#e5c07b>}</span><span>: </span><span style=color:#c678dd>let
</span><span>    </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-linux"</span><span>;
</span><span>    </span><span style=color:#e5c07b>pkgs </span><span style=color:#c678dd>= </span><span style=color:#61afef>import </span><span style=color:#e06c75>nixpkgs </span><span>{ </span><span style=color:#c678dd>inherit </span><span style=color:#e5c07b>system</span><span>; };
</span><span>  </span><span style=color:#c678dd>in </span><span>{
</span><span>    </span><span style=color:#e5c07b>devShell</span><span>.</span><span style=color:#c678dd>${</span><span style=color:#e06c75>system</span><span style=color:#c678dd>} = </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>      </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>        </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>rustup
</span><span>      ];
</span><span>
</span><span>      </span><span style=color:#e5c07b>shellHook </span><span style=color:#c678dd>= </span><span style=color:#98c379>''
</span><span style=color:#98c379>        # Avoid polluting the home directory
</span><span style=color:#98c379>        export RUSTUP_HOME=$(pwd)/.rustup/
</span><span style=color:#98c379>        export CARGO_HOME=$(pwd)/.cargo/
</span><span style=color:#98c379>
</span><span style=color:#98c379>        # Use binaries installed with `cargo install`
</span><span style=color:#98c379>        export PATH=$PATH:$CARGO_HOME/bin
</span><span style=color:#98c379>
</span><span style=color:#98c379>        # Install and display the current toolchain
</span><span style=color:#98c379>        rustup show
</span><span style=color:#98c379>      ''</span><span>;
</span><span>    };
</span><span>  };
</span><span>}
</span></code></pre><p>The most important component of this flake is the <code>buildInputs</code> and <code>shellHook</code> attributes. The <code>buildInputs</code> list specifies the system package of our environment. Currently, we only have <code>rustup</code>, but that’s enough for a simple Rust environment. The <code>shellHook</code> script is executed when we activate the environment. Currently, it sets the rustup and cargo installation path to make this project more self-contained, and show the current toolchain. If we activate the development shell with <code>nix develop</code>, this will be printed:<pre style=color:#dcdfe4;background-color:#282c34><code><span>Default host: x86_64-unknown-linux-gnu
</span><span>rustup home:  .../.rustup/
</span><span>
</span><span>no active toolchain
</span></code></pre><p>You might be tempted to install a toolchain with the <code>rustup toolchain install</code> command, which is perfectly fine, but there’s a more declarative and self-contained way, using <a href=//rust-lang.github.io/rustup/overrides.html#the-toolchain-file><code>rust-toolchain.toml</code></a>. This approach fits the NixOS mentality better, and is also a standardized way to configure per-project Rust toolchains.<pre class=language-toml data-lang=toml style=color:#dcdfe4;background-color:#282c34><code class=language-toml data-lang=toml><span>[toolchain]
</span><span style=color:#e06c75>channel </span><span>= </span><span style=color:#98c379>"stable"
</span><span style=color:#e06c75>components </span><span>= [ </span><span style=color:#98c379>"rust-analyzer" </span><span>]
</span><span style=color:#e06c75>profile </span><span>= </span><span style=color:#98c379>"minimal"
</span></code></pre><p>I also added the <code>rust-analyzer</code> component for IDE integration while we’re at it. Exiting and re-entering the environment, you’ll see <code>rustup</code> installing our Rust environment. Pay attention to the last two line.<pre style=color:#dcdfe4;background-color:#282c34><code><span>stable-2025-01-09-x86_64-unknown-linux-gnu (overridden by '.../rust-toolchain.toml')
</span><span>rustc 1.84.0 (9fc6b4312 2025-01-07)
</span></code></pre><p>Pay attention to the last two line. It shows that the installed toolchain version is <code>stable-2025-01-09</code>. For reproducibility, let’s pin that version in our <code>rust-toolchain.toml</code> file. If you need an older compiler for whatever reason, look up the compiler version in <a href=https://ziap.github.io/blog/nixos-cross-compilation/releases.rs/docs/>releases.rs</a> and grab the release date.<pre class=language-toml data-lang=toml style=color:#dcdfe4;background-color:#282c34><code class=language-toml data-lang=toml><span>[toolchain]
</span><span style=color:#e06c75>channel </span><span>= </span><span style=color:#98c379>"stable-2025-01-09"
</span></code></pre><p>We’re finished with the baseline Rust project. You can now create and build a Rust application:<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span style=color:#e06c75>$</span><span> cargo init .</span><span style=color:#e06c75> --name</span><span> example
</span><span style=color:#e06c75>$</span><span> cargo build</span><span style=color:#e06c75> --release
</span><span style=color:#e06c75>$</span><span> file target/release/example
</span></code></pre><p>It will show that the application is a dynamically linked 64-bit ELF executable. So let’s try to change that.<h2 id=add-the-musl-target>Add the Musl target</h2><p>As mentioned above, I’ll use Musl as a Glibc alternative to statically link the application. Let’s try the steps that I roughly remember from Fedora:<p><strong>Step 1:</strong> Install the system packages required for cross-compiling to your target. For this, we’ll have to edit the Nix flake and add more build inputs. For now, the Musl-configured C compiler is all we need.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span>{
</span><span>  </span><span style=color:#5c6370># ...
</span><span>  </span><span style=color:#e5c07b>devShell</span><span>.</span><span style=color:#c678dd>${</span><span style=color:#e06c75>system</span><span style=color:#c678dd>} = let
</span><span>    </span><span style=color:#e5c07b>pkgsMusl </span><span style=color:#c678dd>= </span><span style=color:#61afef>import </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>path </span><span>{
</span><span>      </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#e06c75>system</span><span>;
</span><span>      </span><span style=color:#e5c07b>crossSystem </span><span style=color:#c678dd>= </span><span>{
</span><span>        </span><span style=color:#e5c07b>config </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-unknown-linux-musl"</span><span>;
</span><span>      };
</span><span>    };
</span><span>  </span><span style=color:#c678dd>in </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>    </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>      </span><span style=color:#e06c75>pkgsMusl</span><span style=color:#c678dd>.</span><span style=color:#e06c75>stdenv</span><span style=color:#c678dd>.</span><span style=color:#e06c75>cc
</span><span>      </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>rustup
</span><span>    ];
</span><span>
</span><span>    </span><span style=color:#5c6370># ...
</span><span>  };
</span><span>}
</span></code></pre><p><strong>Step 2:</strong> Add the target to rustup. Instead of using <code>rustup target add</code>, we’ll edit the <code>rust-toolchain.toml</code> file for the same reason as above.<pre class=language-toml data-lang=toml style=color:#dcdfe4;background-color:#282c34><code class=language-toml data-lang=toml><span>[toolchain]
</span><span style=color:#5c6370># ...
</span><span style=color:#e06c75>targets </span><span>= [ </span><span style=color:#98c379>"x86_64-unknown-linux-musl" </span><span>]
</span></code></pre><p><strong>Step 3:</strong> Compiling with the <code>--target</code> argument. To avoid passing <code>--target</code> all the time, we can set the <code>CARGO_BUILD_TARGET</code> environment variable.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>  </span><span style=color:#5c6370># ...
</span><span>  </span><span style=color:#e5c07b>CARGO_BUILD_TARGET </span><span style=color:#c678dd>= let
</span><span>    </span><span style=color:#e5c07b>toolchainStr </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>readFile </span><span style=color:#98c379>./rust-toolchain.toml</span><span>;
</span><span>    </span><span style=color:#e5c07b>targets </span><span style=color:#c678dd>= </span><span>(</span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>fromTOML toolchainStr</span><span>)</span><span style=color:#c678dd>.</span><span style=color:#e06c75>toolchain</span><span style=color:#c678dd>.</span><span style=color:#e06c75>targets</span><span>;
</span><span>  </span><span style=color:#c678dd>in </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>head targets</span><span>;
</span><span>  </span><span style=color:#5c6370># ...
</span><span>}
</span></code></pre><p>This will read the <code>rust-toolchain.toml</code> file and grab the first specified target. Building again, we will indeed get a statically linked executable.<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span style=color:#e06c75>$</span><span> cargo build
</span><span style=color:#e06c75>$</span><span> file target/x86_64-unknown-linux-musl/release/example
</span></code></pre><p>So the cross-compiling environment worked, at least for the task of linking against a different libc. Let’s try building something more complicated, what about this site’s <a href=//www.getzola.org/>generator</a>?<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span style=color:#e06c75>$</span><span> cargo install</span><span style=color:#e06c75> --git</span><span> https://github.com/getzola/zola.git</span><span style=color:#e06c75> --target</span><span style=color:#c678dd>=</span><span>x86_64-unknown-linux-musl
</span></code></pre><p>The compilation failed because a C library can’t be built. This is because the C compiler and linker are not set up correctly. I don’t know why this is the case only for building C libraries, but it is what is it. To fix this problem, We can add these two environment variables:<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span>{
</span><span>  </span><span style=color:#5c6370># ...
</span><span>  </span><span style=color:#e5c07b>devShell</span><span>.</span><span style=color:#c678dd>${</span><span style=color:#e06c75>system</span><span style=color:#c678dd>} = let
</span><span>    </span><span style=color:#e5c07b>pkgsMusl </span><span style=color:#c678dd>= </span><span style=color:#61afef>import </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>path </span><span>{
</span><span>      </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#e06c75>system</span><span>;
</span><span>      </span><span style=color:#e5c07b>crossSystem </span><span style=color:#c678dd>= </span><span>{
</span><span>        </span><span style=color:#e5c07b>config </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-unknown-linux-musl"</span><span>;
</span><span>      };
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#e5c07b>ccMusl </span><span style=color:#c678dd>= </span><span style=color:#e06c75>pkgsMusl</span><span style=color:#c678dd>.</span><span style=color:#e06c75>stdenv</span><span style=color:#c678dd>.</span><span style=color:#e06c75>cc</span><span>;
</span><span>  </span><span style=color:#c678dd>in </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>    </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>      </span><span style=color:#e06c75>ccMusl
</span><span>      </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>rustup
</span><span>    ];
</span><span>
</span><span>    
</span><span>    </span><span style=color:#5c6370># IMPORTANT! Set up the compiler and linker for C libraries
</span><span>    </span><span style=color:#e5c07b>CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER </span><span style=color:#c678dd>= </span><span style=color:#e06c75>ccMusl</span><span>;
</span><span>    </span><span style=color:#e5c07b>CC_x86_64_unknown_linux_musl </span><span style=color:#c678dd>= </span><span style=color:#e06c75>ccMusl</span><span>;
</span><span>
</span><span>    </span><span style=color:#5c6370># ...
</span><span>  };
</span><span>}
</span></code></pre><p>So this adds a 4th step to our process: “Set up the C compiler and linker for the target”. This might also be important in non NixOS environments, but previously I haven’t tried building a project with C dependencies. With this, we finally manage to build and install a statically linked Zola.<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span style=color:#e06c75>$</span><span> cargo install</span><span style=color:#e06c75> --git</span><span> https://github.com/getzola/zola.git</span><span style=color:#e06c75> --target</span><span style=color:#c678dd>=</span><span>x86_64-unknown-linux-musl
</span><span style=color:#e06c75>$</span><span> file `</span><span style=color:#e06c75>which</span><span> zola`
</span></code></pre><h2 id=add-the-windows-target>Add the Windows target</h2><p>Cross-compiling to Windows is fairly easy thanks to the <a href=//www.mingw-w64.org/>MinGW-w64 project</a>. You might be heard of it as a “GCC on Windows” program. But you can also use its compiling to Windows capabilities on Linux for cross-compilation. Compiling Rust to Windows is similar to linking against Musl, so let’s try the steps mentioned above. Here’s the final flake after these 4 steps:<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span>{
</span><span>  </span><span style=color:#e5c07b>description </span><span style=color:#c678dd>= </span><span style=color:#98c379>"A basic Rust flake"</span><span>;
</span><span>
</span><span>  </span><span style=color:#e5c07b>inputs </span><span style=color:#c678dd>= </span><span>{
</span><span>    </span><span style=color:#e5c07b>nixpkgs</span><span>.</span><span style=color:#e5c07b>url </span><span style=color:#c678dd>= </span><span style=color:#98c379>"nixpkgs/nixos-unstable"</span><span>;
</span><span>  };
</span><span>
</span><span>  </span><span style=color:#e5c07b>outputs </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{ </span><span>self</span><span style=color:#c678dd>, </span><span>nixpkgs </span><span style=color:#e5c07b>}</span><span>: </span><span style=color:#c678dd>let
</span><span>    </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-linux"</span><span>;
</span><span>    </span><span style=color:#e5c07b>pkgs </span><span style=color:#c678dd>= </span><span style=color:#61afef>import </span><span style=color:#e06c75>nixpkgs </span><span>{ </span><span style=color:#c678dd>inherit </span><span style=color:#e5c07b>system</span><span>; };
</span><span>  </span><span style=color:#c678dd>in </span><span>{
</span><span>    </span><span style=color:#e5c07b>devShell</span><span>.</span><span style=color:#c678dd>${</span><span style=color:#e06c75>system</span><span style=color:#c678dd>} = let
</span><span>      </span><span style=color:#e5c07b>targetName </span><span style=color:#c678dd>= </span><span>{
</span><span>        </span><span style=color:#e5c07b>mingw </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-w64-mingw32"</span><span>;
</span><span>        </span><span style=color:#e5c07b>musl </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-unknown-linux-musl"</span><span>;
</span><span>      };
</span><span>
</span><span>      </span><span style=color:#5c6370># Generate the cross compilation packages import
</span><span>      </span><span style=color:#e5c07b>pkgsCross </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mapAttrs </span><span>(name: value: </span><span style=color:#61afef>import </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>path </span><span>{
</span><span>        </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#e06c75>system</span><span>;
</span><span>        </span><span style=color:#e5c07b>crossSystem </span><span style=color:#c678dd>= </span><span>{
</span><span>          </span><span style=color:#e5c07b>config </span><span style=color:#c678dd>= </span><span style=color:#e06c75>value</span><span>;
</span><span>        };
</span><span>      }) </span><span style=color:#e06c75>targetName</span><span>;
</span><span>
</span><span>      </span><span style=color:#5c6370># Grab the corresponding C compiler binaries
</span><span>      </span><span style=color:#e5c07b>ccPkgs </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mapAttrs </span><span>(name: value: </span><span style=color:#e06c75>value</span><span style=color:#c678dd>.</span><span style=color:#e06c75>stdenv</span><span style=color:#c678dd>.</span><span style=color:#e06c75>cc</span><span>) </span><span style=color:#e06c75>pkgsCross</span><span>;
</span><span>      </span><span style=color:#e5c07b>cc </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mapAttrs </span><span>(name: value: </span><span style=color:#98c379>"</span><span style=color:#c678dd>${</span><span style=color:#e06c75>value</span><span style=color:#c678dd>}</span><span style=color:#98c379>/bin/</span><span style=color:#c678dd>${</span><span style=color:#e06c75>targetName</span><span style=color:#c678dd>.${</span><span style=color:#e06c75>name</span><span style=color:#c678dd>}}</span><span style=color:#98c379>-cc"</span><span>) </span><span style=color:#e06c75>ccPkgs</span><span>;
</span><span>    </span><span style=color:#c678dd>in </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>      </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>        </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>rustup
</span><span>      ] </span><span style=color:#c678dd>++ </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>attrValues ccPkgs</span><span>;
</span><span>
</span><span>      </span><span style=color:#5c6370># Set the default target to the first available target
</span><span>      </span><span style=color:#e5c07b>CARGO_BUILD_TARGET </span><span style=color:#c678dd>= let
</span><span>        </span><span style=color:#e5c07b>toolchainStr </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>readFile </span><span style=color:#98c379>./rust-toolchain.toml</span><span>;
</span><span>        </span><span style=color:#e5c07b>targets </span><span style=color:#c678dd>= </span><span>(</span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>fromTOML toolchainStr</span><span>)</span><span style=color:#c678dd>.</span><span style=color:#e06c75>toolchain</span><span style=color:#c678dd>.</span><span style=color:#e06c75>targets</span><span>;
</span><span>      </span><span style=color:#c678dd>in </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>head targets</span><span>;
</span><span>
</span><span>      </span><span style=color:#5c6370># Set up the C compiler
</span><span>      </span><span style=color:#e5c07b>CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER </span><span style=color:#c678dd>= </span><span style=color:#e06c75>cc</span><span style=color:#c678dd>.</span><span style=color:#e06c75>musl</span><span>;
</span><span>      </span><span style=color:#e5c07b>CARGO_TARGET_X86_64_PC_WINDOWS_GNU_LINKER </span><span style=color:#c678dd>= </span><span style=color:#e06c75>cc</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mingw</span><span>;
</span><span>
</span><span>      </span><span style=color:#5c6370># Set up the C linker
</span><span>      </span><span style=color:#e5c07b>CC_x86_64_unknown_linux_musl </span><span style=color:#c678dd>= </span><span style=color:#e06c75>cc</span><span style=color:#c678dd>.</span><span style=color:#e06c75>musl</span><span>;
</span><span>      </span><span style=color:#e5c07b>CC_x86_64_pc_windows_gnu </span><span style=color:#c678dd>= </span><span style=color:#e06c75>cc</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mingw</span><span>;
</span><span>
</span><span>      </span><span style=color:#e5c07b>shellHook </span><span style=color:#c678dd>= </span><span style=color:#98c379>''
</span><span style=color:#98c379>        # Avoid polluting home directory
</span><span style=color:#98c379>        export RUSTUP_HOME=$(pwd)/.rustup/
</span><span style=color:#98c379>        export CARGO_HOME=$(pwd)/.cargo/
</span><span style=color:#98c379>
</span><span style=color:#98c379>        # Use binaries installed with `cargo install`
</span><span style=color:#98c379>        export PATH=$PATH:$CARGO_HOME/bin
</span><span style=color:#98c379>
</span><span style=color:#98c379>        # Install and display the current toolchain
</span><span style=color:#98c379>        rustup show
</span><span style=color:#98c379>      ''</span><span>;
</span><span>    };
</span><span>  };
</span><span>}
</span></code></pre><p>And here’s the new <code>rust-toolchain.toml</code>. The only difference is the added <code>x86_64-pc-windows-gnu</code> target. I’ll also set it as the default target by moving it to the front.<pre class=language-toml data-lang=toml style=color:#dcdfe4;background-color:#282c34><code class=language-toml data-lang=toml><span>[toolchain]
</span><span style=color:#e06c75>channel </span><span>= </span><span style=color:#98c379>"stable-2025-01-09"
</span><span style=color:#e06c75>components </span><span>= [ </span><span style=color:#98c379>"rust-analyzer" </span><span>]
</span><span style=color:#e06c75>profile </span><span>= </span><span style=color:#98c379>"minimal"
</span><span style=color:#e06c75>targets </span><span>= [ </span><span style=color:#98c379>"x86_64-pc-windows-gnu"</span><span>, </span><span style=color:#98c379>"x86_64-unknown-linux-musl" </span><span>]
</span></code></pre><p>Compiling our example with <code>cargo build</code>, we get the following error:<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span>  </span><span style=color:#c678dd>= </span><span style=color:#e06c75>note:</span><span> /nix/store/.../bin/x86_64-w64-mingw32-ld: cannot find</span><span style=color:#e06c75> -l</span><span>:libpthread.a: No such file or directory
</span><span>          </span><span style=color:#e06c75>collect2:</span><span> error: ld returned 1 exit status
</span></code></pre><p>So we need to add <code>libpthread</code> as a linker flag. I use the constructs below to make adding additional libraries easier by listing out the Nix packages.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>  </span><span style=color:#e5c07b>RUSTFLAGS </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#61afef>map </span><span>(a: </span><span style=color:#98c379>"-L </span><span style=color:#c678dd>${</span><span style=color:#e06c75>a</span><span style=color:#c678dd>}</span><span style=color:#98c379>/lib"</span><span>) [
</span><span>    </span><span style=color:#e06c75>pkgsCross</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mingw</span><span style=color:#c678dd>.</span><span style=color:#e06c75>windows</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mingw_w64_pthreads
</span><span>  ];
</span><span>}
</span></code></pre><p>With this, we’re now capable of building both the example and Zola, and you can run the resulting binaries with <a href=//www.winehq.org/>Wine</a>. But you can’t use commands such as <code>cargo run</code> and <code>cargo test</code>, and using Wine will bring configuration from your system Wine prefix, which will hurt reproducibility. So let’s set up Wine, create a local Wine prefix and set it as the runner for Cargo.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span style=color:#c678dd>let
</span><span>  </span><span style=color:#5c6370># ...
</span><span>  </span><span style=color:#e5c07b>wine </span><span style=color:#c678dd>= </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>wineWowPackages</span><span style=color:#c678dd>.</span><span style=color:#e06c75>stable</span><span>;
</span><span style=color:#c678dd>in </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>  </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>    </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>rustup
</span><span>    </span><span style=color:#e06c75>wine
</span><span>  ] </span><span style=color:#c678dd>++ </span><span style=color:#e5c07b>builtins</span><span style=color:#c678dd>.</span><span style=color:#e06c75>attrValues ccPkgs</span><span>;
</span><span>  
</span><span>  </span><span style=color:#5c6370># ...
</span><span>
</span><span>  </span><span style=color:#5c6370># Use wine for `cargo run`, `cargo test`, etc.
</span><span>  </span><span style=color:#e5c07b>CARGO_TARGET_X86_64_PC_WINDOWS_GNU_RUNNER </span><span style=color:#c678dd>= </span><span style=color:#98c379>"</span><span style=color:#c678dd>${</span><span style=color:#e06c75>wine</span><span style=color:#c678dd>}</span><span style=color:#98c379>/bin/wine64"</span><span>;
</span><span>
</span><span>  </span><span style=color:#e5c07b>shellHook </span><span style=color:#c678dd>= </span><span style=color:#98c379>''
</span><span style=color:#98c379>    # Avoid polluting the home directory
</span><span style=color:#98c379>    export RUSTUP_HOME=$(pwd)/.rustup/
</span><span style=color:#98c379>    export CARGO_HOME=$(pwd)/.cargo/
</span><span style=color:#98c379>    export WINEPREFIX=$(pwd)/.wine/
</span><span style=color:#98c379>
</span><span style=color:#98c379>    # Use binaries installed with `cargo install`
</span><span style=color:#98c379>    export PATH=$PATH:$CARGO_HOME/bin
</span><span style=color:#98c379>
</span><span style=color:#98c379>    # Install and display the current toolchain
</span><span style=color:#98c379>    rustup show
</span><span style=color:#98c379>  ''</span><span>;
</span><span>}
</span></code></pre><p>So we finished our flake for cross compiling Rust using Musl and MinGW. There might be problems with it, like how we encountered one before adding the compiler and linker environment variables. But the cool thing with Nix is that once you solve a problem, the solution is reproducible, so you practically solved it forever.<h1 id=zig>Zig</h1><p>If you think that we did above is utterly insane, don’t worry. Zig is much, much easier to set up. Here’s the baseline flake for a Zig project.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span>{
</span><span>  </span><span style=color:#e5c07b>description </span><span style=color:#c678dd>= </span><span style=color:#98c379>"A basic Zig flake"</span><span>;
</span><span>
</span><span>  </span><span style=color:#e5c07b>inputs </span><span style=color:#c678dd>= </span><span>{
</span><span>    </span><span style=color:#e5c07b>nixpkgs</span><span>.</span><span style=color:#e5c07b>url </span><span style=color:#c678dd>= </span><span style=color:#98c379>"nixpkgs/nixos-unstable"</span><span>;
</span><span>  };
</span><span>
</span><span>  </span><span style=color:#e5c07b>outputs </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>{ </span><span>self</span><span style=color:#c678dd>, </span><span>nixpkgs </span><span style=color:#e5c07b>}</span><span>: </span><span style=color:#c678dd>let
</span><span>    </span><span style=color:#e5c07b>system </span><span style=color:#c678dd>= </span><span style=color:#98c379>"x86_64-linux"</span><span>;
</span><span>    </span><span style=color:#e5c07b>pkgs </span><span style=color:#c678dd>= </span><span style=color:#61afef>import </span><span style=color:#e06c75>nixpkgs </span><span>{ </span><span style=color:#c678dd>inherit </span><span style=color:#e5c07b>system</span><span>; };
</span><span>  </span><span style=color:#c678dd>in </span><span>{
</span><span>    </span><span style=color:#e5c07b>devShell</span><span>.</span><span style=color:#c678dd>${</span><span style=color:#e06c75>system</span><span style=color:#c678dd>} = </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>      </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>        </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>zig
</span><span>      ];
</span><span>    };
</span><span>  };
</span><span>}
</span></code></pre><p>That’s it. No toolchain management, not setting up PATHs, not even a shell hook. This is because everything is self-contained in the zig package. Also, guess what, cross-compilation is supported out of the box. You don’t even need to add system packages.<pre class=language-bash data-lang=bash style=color:#dcdfe4;background-color:#282c34><code class=language-bash data-lang=bash><span style=color:#e06c75>zig</span><span> init
</span><span style=color:#e06c75>zig</span><span> build</span><span style=color:#e06c75> -Dtarget</span><span style=color:#c678dd>=</span><span>x86_64-linux-musl
</span><span style=color:#e06c75>zig</span><span> build</span><span style=color:#e06c75> -Dtarget</span><span style=color:#c678dd>=</span><span>x86_64-windows-gnu
</span><span>
</span><span style=color:#e06c75>file</span><span> zig-out/bin/example
</span><span style=color:#e06c75>file</span><span> zig-out/bin/example.exe
</span></code></pre><p>In fact, remember how I said that another way to make a statically linked binary is to skip the libc layer and directly invoke system calls? In Zig, libc is optional, so everything is statically linked by default. I want to say good things about Zig and its ease of installation, but that the topic for another article.<p>However, similar to Rust, you need to set up Wine to use <code>zig build run</code> or <code>zig build test</code> when cross compiling to Windows. The process is pretty straightforward, add the Wine package, create a local Wine prefix and tell the build system to use Wine.<pre class=language-nix data-lang=nix style=color:#dcdfe4;background-color:#282c34><code class=language-nix data-lang=nix><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>mkShell </span><span>{
</span><span>  </span><span style=color:#e5c07b>buildInputs </span><span style=color:#c678dd>= </span><span>[
</span><span>    </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>zig
</span><span>    </span><span style=color:#e06c75>pkgs</span><span style=color:#c678dd>.</span><span style=color:#e06c75>wineWowPackages</span><span style=color:#c678dd>.</span><span style=color:#e06c75>stable
</span><span>  ];
</span><span>
</span><span>  </span><span style=color:#e5c07b>shellHook </span><span style=color:#c678dd>= </span><span style=color:#98c379>''
</span><span style=color:#98c379>    export WINEPREFIX=$(pwd)/.wine/
</span><span style=color:#98c379>  ''</span><span>;
</span><span>}
</span></code></pre><pre class=language-zig data-lang=zig style=color:#dcdfe4;background-color:#282c34><code class=language-zig data-lang=zig><span style=color:#c678dd>pub fn </span><span style=color:#61afef>build</span><span>(</span><span style=color:#e06c75>b</span><span>: </span><span style=color:#c678dd>*std.Build</span><span>) </span><span style=color:#c678dd>void </span><span>{
</span><span>  </span><span style=color:#5c6370>// ...
</span><span>
</span><span>  </span><span style=color:#5c6370>// Detect cross-compilation and enable Wine
</span><span>  </span><span style=color:#c678dd>if </span><span>(target.result.os.tag </span><span style=color:#c678dd>==</span><span style=color:#e5c07b> .windows </span><span style=color:#c678dd>and</span><span> builtin.os.tag </span><span style=color:#c678dd>!=</span><span style=color:#e5c07b> .windows</span><span>) {
</span><span>    b.enable_wine </span><span style=color:#c678dd>= </span><span style=color:#e5c07b>true</span><span>;
</span><span>  }
</span><span>  </span><span style=color:#5c6370>// ...
</span><span>}
</span></code></pre><p>As you can see, it’s very easy to create a Zig cross-compiling environment. But to be honest, as everything is bundled with Zig already, if I don’t need Wine or don’t care too much about reproducibility, I’d just use a simple <a href=//nix.dev/tutorials/first-steps/ad-hoc-shell-environments.html>ad-hoc shell</a>.<h1 id=c-and-c>C and C++</h1><p>Just when you think that it couldn’t get better, Zig supports compiling C and C++, with cross-compilation support, out of the box, in a single package. The fact that they managed to pull this off is baffling to be. This means that we can just use our Zig environment for C and C++ development. The build script is different, but it’s project-dependent anyway, so I won’t show it here.<p>If you want an example project, here’s <a href=//github.com/ziap/svgv>one</a>. Although the project requires Gdi+, I can comfortably develop it on Linux, run it with Wine or send it to my Windows VM. There was no <code>flake.nix</code> because I used to just create an ad-hoc shell every time I need Wine and the Zig compiler.<p>Using Zig to build C or C++ also allows us to benefit from incremental compilation and the smart caching system. Zig is also surprisingly good for writing build scripts, even better than CMake and the like. If you don’t want a full-blown build system, or needs to integrate with one that supports a more traditional compiler, you can use the <code>zig cc</code> or <code>zig c++</code> command which still support cross-compilation and incremental compilation.<h1 id=conclusion>Conclusion</h1><p>This article shown how to set up a cross-compiling NixOS environment for some programming language. It focused mostly on Rust, as it’s the hardest language to set up. Setting up that environment is not trivial, as it requires knowledge of both the Nix ecosystem and the language toolchain. But I think that the reproducibility is totally worth it. Every time I want to make a new Rust project, I just need to grab the <code>flake.nix</code> and <code>rust-toolchain.toml</code> files, and <code>nix develop</code> myself into the newly created environment. Trying to cross-compile also shows many of Zig’s advantages. The biggest of which being that it was a new language designed from the ground up with the intention of having cross-compiling as a first class use case.<p>Modern software is needlessly complicated to set up, and I think that projects such as Docker and NixOS are not long term solutions. I think that the only reliable solution is to have easy distribution as a goal from the start. Cross-compilation is one method to prevent you from straying too far away from that goal. If you can cross-compile your code and run it on another target, it means that your application is portable and reliable, which usually makes them trivial to set up and use.</article></main><footer class=footer__container><svg viewbox="0 352.5 960 188.5" class=footer__split preserveaspectratio=none version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink><path d="M0 441L22.8 424.5C45.7 408 91.3 375 137 360.8C182.7 346.7 228.3 351.3 274 369.3C319.7 387.3 365.3 418.7 411.2 414.2C457 409.7 503 369.3 548.8 368C594.7 366.7 640.3 404.3 686 421.7C731.7 439 777.3 436 823 429.8C868.7 423.7 914.3 414.3 937.2 409.7L960 405L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#f7f9fb /><path d="M0 477L22.8 467C45.7 457 91.3 437 137 423.8C182.7 410.7 228.3 404.3 274 401.7C319.7 399 365.3 400 411.2 413.5C457 427 503 453 548.8 464.2C594.7 475.3 640.3 471.7 686 456.5C731.7 441.3 777.3 414.7 823 404.5C868.7 394.3 914.3 400.7 937.2 403.8L960 407L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#eff3f7 /><path d="M0 459L22.8 456.2C45.7 453.3 91.3 447.7 137 456.7C182.7 465.7 228.3 489.3 274 494.8C319.7 500.3 365.3 487.7 411.2 476C457 464.3 503 453.7 548.8 451.7C594.7 449.7 640.3 456.3 686 462.5C731.7 468.7 777.3 474.3 823 473.2C868.7 472 914.3 464 937.2 460L960 456L960 541L937.2 541C914.3 541 868.7 541 823 541C777.3 541 731.7 541 686 541C640.3 541 594.7 541 548.8 541C503 541 457 541 411.2 541C365.3 541 319.7 541 274 541C228.3 541 182.7 541 137 541C91.3 541 45.7 541 22.8 541L0 541Z" fill=#e8eef4 stroke=#e8eef4 /></svg><div class=footer__bg><div class=footer>© 2024 Zap (Huy-Giap Bui). Content on this site is licensed under <a href=//creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a>.</div></div></footer></div>